{% extends 'base.html' %}
{% load static %}

{% block title %}PPT æ¨¡æ¿ç¼–è¾‘å™¨ - S2S{% endblock %}

{% block extra_css %}
<style>
    /* æ¨¡æ¿ç¼–è¾‘å™¨å…¨å±å¸ƒå±€ */
    html,
    body {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }

    /* éšè—ä¸»é¡µå¯¼èˆªæ ï¼Œç¼–è¾‘å™¨æœ‰è‡ªå·±çš„é¡¶æ  */
    .navbar {
        display: none !important;
    }

    /* è¦†ç›– base.html ä¸­çš„å®¹å™¨æ ·å¼ */
    .main-content {
        padding: 0 !important;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    .main-content>.container {
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    .footer {
        display: none !important;
    }

    /* å…¨å±ç¼–è¾‘å™¨å®¹å™¨ */
    .template-editor-fullscreen-container {
        flex: 1;
        background: var(--bg-color);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    /* é¡¶éƒ¨å·¥å…·æ  */
    .editor-toolbar {
        height: 70px;
        background: white;
        border-bottom: 1px solid var(--border-color);
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        padding: 0 var(--spacing-xl);
        flex-shrink: 0;
    }

    .editor-toolbar>div:first-child {
        justify-self: start;
    }

    .editor-toolbar h2 {
        margin: 0;
        font-size: 1.4rem;
        color: var(--text-primary);
        text-align: center;
    }

    .editor-toolbar>div:last-child {
        justify-self: end;
    }

    .toolbar-actions {
        display: flex;
        gap: var(--spacing-sm);
    }

    /* ä¸»ç¼–è¾‘åŒºåŸŸ */
    .editor-main {
        flex: 1;
        display: flex;
        overflow: hidden;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    /* å·¦ä¾§é¡µé¢åˆ—è¡¨ */
    .editor-sidebar-left {
        width: 220px;
        background: white;
        border-right: 1px solid var(--border-color);
        overflow-y: auto;
        flex-shrink: 0;
    }

    /* ä¸­é—´ Canvas é¢„è§ˆåŒº */
    .editor-canvas-area {
        flex: 1;
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    .canvas-toolbar {
        height: 50px;
        background: white;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 var(--spacing-md);
        flex-shrink: 0;
    }

    .canvas-container {
        flex: 1;
        overflow: auto;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    /* å³ä¾§å±æ€§é¢æ¿ */
    .editor-sidebar-right {
        width: 320px;
        background: white;
        border-left: 1px solid var(--border-color);
        overflow-y: auto;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
    }

    /* é¡µé¢åˆ—è¡¨é¡¹ */
    .page-item {
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background 0.2s ease;
    }

    .page-item:hover {
        background: var(--bg-hover);
    }

    .page-item.active {
        background: var(--primary-color);
        color: white;
    }

    .page-item-title {
        font-weight: 600;
        margin-bottom: 4px;
    }

    .page-item-info {
        font-size: 0.85rem;
        opacity: 0.8;
    }

    /* å±æ€§é¢æ¿ Tab */
    .property-tabs {
        display: flex;
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
    }

    .property-tab {
        flex: 1;
        padding: var(--spacing-sm);
        border: none;
        background: none;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--text-secondary);
        transition: all 0.2s ease;
        border-bottom: 2px solid transparent;
    }

    .property-tab.active {
        color: var(--primary-color);
        border-bottom-color: var(--primary-color);
        font-weight: 600;
    }

    .property-content {
        flex: 1;
        overflow-y: auto;
        padding: var(--spacing-md);
    }

    /* æ‰¹é‡æ“ä½œæ  */
    .batch-actions-bar {
        padding: var(--spacing-sm) var(--spacing-md);
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
    }

    .batch-actions-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--spacing-xs);
    }

    .batch-actions-title {
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .element-stats {
        font-size: 0.75rem;
        color: var(--text-secondary);
        background: white;
        padding: 2px 8px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
    }

    .batch-actions-buttons {
        display: flex;
        gap: var(--spacing-xs);
        flex-wrap: wrap;
    }

    .batch-btn {
        flex: 1;
        min-width: 0;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        background: white;
        color: var(--text-color);
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .batch-btn:hover {
        border-color: var(--primary-color);
        background: var(--bg-hover);
        color: var(--primary-color);
    }

    .batch-btn-accent {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: transparent;
    }

    .batch-btn-accent:hover {
        opacity: 0.9;
        color: white;
        border-color: transparent;
    }

    .batch-btn-ai {
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        color: white;
        border-color: transparent;
        flex: 1 1 100%;
    }

    .batch-btn-ai:hover {
        opacity: 0.9;
        color: white;
        border-color: transparent;
    }

    .batch-btn-small {
        flex: 0 0 auto;
        min-width: auto;
        padding: 4px 8px;
    }

    /* å¤šé€‰æ¨¡å¼åˆ‡æ¢ */
    .select-mode-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        color: var(--text-secondary);
        user-select: none;
    }

    .select-mode-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: var(--primary-color);
    }

    .select-mode-toggle:hover {
        color: var(--primary-color);
    }

    /* å…ƒç´ å¤é€‰æ¡† */
    .element-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary-color);
        flex-shrink: 0;
    }

    .element-item.multi-select-mode {
        cursor: default;
    }

    .element-item.multi-selected {
        border-color: var(--primary-color);
        background: rgba(52, 152, 219, 0.1);
    }

    /* å…ƒç´ åˆ—è¡¨ */
    .element-item {
        padding: var(--spacing-sm);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: var(--spacing-sm);
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .element-item:hover {
        border-color: var(--primary-color);
        background: var(--bg-hover);
    }

    .element-item.selected {
        border-color: var(--primary-color);
        background: rgba(52, 152, 219, 0.1);
    }

    .element-number {
        display: inline-block;
        width: 24px;
        height: 24px;
        line-height: 24px;
        text-align: center;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        font-size: 0.85rem;
        font-weight: 600;
        margin-right: var(--spacing-sm);
    }

    .element-item.unnamed .element-number {
        background: var(--warning-color);
    }
</style>
{% endblock %}

{% block content %}
<!-- ä¸Šä¼ åŒºåŸŸï¼ˆåˆå§‹æ˜¾ç¤ºï¼‰ -->
<div id="uploadSection" class="template-editor-fullscreen-container">
    <div class="editor-toolbar">
        <div>
            <a href="{% url 'developer_tools_page' %}" class="btn btn-secondary">
                â† è¿”å›å¼€å‘è€…å·¥å…·
            </a>
        </div>
        <h2>ğŸ¨ PPT æ¨¡æ¿ç¼–è¾‘å™¨</h2>
        <div></div>
    </div>

    <div class="editor-main" style="align-items: center; justify-content: center;">
        <div class="card" style="max-width: 600px; width: 100%; margin: var(--spacing-xl);">
            <div class="card-header">
                <h3>ğŸ“¤ ä¸Šä¼  PPT æ¨¡æ¿</h3>
            </div>
            <div class="card-body">
                <form id="uploadTemplateForm" enctype="multipart/form-data">
                    {% csrf_token %}
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹© PPT æ–‡ä»¶</label>
                        <div class="file-upload-wrapper">
                            <input type="file" id="pptFileInput" name="ppt_file" accept=".pptx" required>
                            <label for="pptFileInput" class="file-upload-label">
                                <span id="fileNameDisplay">ğŸ“ ç‚¹å‡»é€‰æ‹© PPT æ–‡ä»¶</span>
                            </label>
                        </div>
                        <p style="margin-top: var(--spacing-sm); font-size: 0.9rem; color: var(--text-secondary);">
                            æ”¯æŒ .pptx æ ¼å¼ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è½¬æ¢ä¸º PDF å¹¶ç”Ÿæˆé¢„è§ˆ
                        </p>
                    </div>

                    <div style="margin-top: var(--spacing-lg);">
                        <button type="submit" class="btn btn-primary btn-large" style="width: 100%;">
                            ğŸš€ å¼€å§‹ç¼–è¾‘
                        </button>
                    </div>
                </form>

                <div
                    style="margin-top: var(--spacing-lg); padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--border-radius);">
                    <h4 style="margin-top: 0;">ğŸ“– ä½¿ç”¨è¯´æ˜</h4>
                    <ol style="margin: 0; padding-left: 1.5rem; line-height: 1.8;">
                        <li>ä¸Šä¼  PPT æ¨¡æ¿æ–‡ä»¶ï¼ˆ.pptx æ ¼å¼ï¼‰</li>
                        <li>ç³»ç»Ÿä¼šè‡ªåŠ¨ä½¿ç”¨ LibreOffice è½¬æ¢ä¸º PDF å¹¶ç”Ÿæˆé¢„è§ˆ</li>
                        <li>ç³»ç»Ÿä¼šè‡ªåŠ¨æå–æ‰€æœ‰å¯ç¼–è¾‘å…ƒç´ å¹¶æ ‡æ³¨ç¼–å·ï¼ˆâ‘ â‘¡â‘¢...ï¼‰</li>
                        <li>ç‚¹å‡»é¢„è§ˆåŒºçš„å…ƒç´ æˆ–ç¼–å·ï¼Œåœ¨å³ä¾§é¢æ¿ä¸ºå…ƒç´ å‘½å</li>
                        <li>ä½¿ç”¨è¯­ä¹‰åŒ–åç§°ï¼Œå¦‚"æ ‡é¢˜åŒº"ã€"ä½œè€…å"ã€"ä¸»è¦å†…å®¹"ç­‰</li>
                        <li>å®Œæˆåç‚¹å‡»"ä¿å­˜ PPT"å’Œ"ç”Ÿæˆé…ç½® JSON"</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ç¼–è¾‘å™¨åŒºåŸŸï¼ˆä¸Šä¼ æˆåŠŸåæ˜¾ç¤ºï¼‰ -->
<div id="editorSection" class="template-editor-fullscreen-container" style="display: none;">
    <div class="editor-toolbar">
        <div>
            <a href="{% url 'developer_tools_page' %}" class="btn btn-secondary">
                â† è¿”å›å¼€å‘è€…å·¥å…·
            </a>
        </div>
        <h2 id="editorTitle">ğŸ¨ PPT æ¨¡æ¿ç¼–è¾‘å™¨</h2>
        <div class="toolbar-actions">
            <button id="aiAutoNameAllBtn" class="btn btn-warning" title="ä½¿ç”¨ AI è‡ªåŠ¨ä¸ºæ‰€æœ‰é¡µé¢å…ƒç´ å‘½åï¼ˆé€é¡µå¤„ç†ï¼‰">
                ğŸ¤– AI ä¸€é”®å‘½å
            </button>
            <button id="saveTemplateBtn" class="btn btn-success">
                ğŸ’¾ ä¿å­˜
            </button>
            <button id="generateConfigBtn" class="btn btn-primary">
                ğŸ“„ ç”Ÿæˆé…ç½®
            </button>
            <button id="uploadNewBtn" class="btn btn-secondary">
                ğŸ“‚ ä¸Šä¼ æ–°æ¨¡æ¿
            </button>
        </div>
    </div>

    <div class="editor-main">
        <!-- å·¦ä¾§é¡µé¢åˆ—è¡¨ -->
        <div class="editor-sidebar-left">
            <div
                style="padding: var(--spacing-md); border-bottom: 1px solid var(--border-color); background: var(--bg-secondary);">
                <h4 style="margin: 0; font-size: 0.95rem;">ğŸ“‘ é¡µé¢åˆ—è¡¨</h4>
            </div>
            <!-- è¿›åº¦æ¡ -->
            <div
                style="padding: var(--spacing-sm); border-bottom: 1px solid var(--border-color); background: var(--bg-color);">
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.25rem;">
                    å·²å‘½å: <span id="namedCount">0 / 0</span> (<span id="progressPercent">0%</span>)
                </div>
                <div style="height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden;">
                    <div id="progressBar"
                        style="height: 100%; background: var(--success-color); width: 0%; transition: width 0.3s ease;">
                    </div>
                </div>
            </div>
            <div id="pageList">
                <!-- Pages will be populated here -->
            </div>
        </div>

        <!-- ä¸­é—´é¢„è§ˆåŒº -->
        <div class="editor-canvas-area">
            <div class="canvas-toolbar">
                <h4 id="currentPageTitle" style="margin: 0;">ç¬¬ 1 é¡µ</h4>
                <div style="display: flex; gap: var(--spacing-sm); align-items: center;">
                    <button id="zoomOutBtn" class="btn btn-secondary btn-small">ğŸ”-</button>
                    <span id="zoomLevel">100%</span>
                    <button id="zoomInBtn" class="btn btn-secondary btn-small">ğŸ”+</button>
                    <button id="fitToWindowBtn" class="btn btn-secondary btn-small">âš™ï¸ é€‚åº”çª—å£</button>
                </div>
            </div>
            <div class="canvas-container" id="canvasContainer">
                <!-- ä½¿ç”¨åç«¯ç”Ÿæˆçš„æ ‡æ³¨å›¾ç‰‡ï¼Œä¸éœ€è¦ Canvas äº¤äº’ -->
                <img id="previewImage" src="" alt="PPT é¢„è§ˆ" style="max-width: 100%; max-height: 100%; display: block;">
            </div>
            <div
                style="padding: var(--spacing-sm); background: white; border-top: 1px solid var(--border-color); font-size: 0.85rem; color: var(--text-secondary); text-align: center;">
                ğŸ’¡ å¿«æ·é”®: â†â†’ åˆ‡æ¢é¡µé¢ | åœ¨å³ä¾§åˆ—è¡¨ä¸­é€‰æ‹©å…ƒç´ è¿›è¡Œå‘½å
            </div>
        </div>

        <!-- å³ä¾§å±æ€§é¢æ¿ -->
        <div class="editor-sidebar-right">
            <div class="property-tabs">
                <button id="elementListTabBtn" class="property-tab active" onclick="switchPropertyTab('list')">
                    ğŸ“‹ å…ƒç´ åˆ—è¡¨
                </button>
                <button id="elementEditTabBtn" class="property-tab" onclick="switchPropertyTab('edit')">
                    âœï¸ ç¼–è¾‘å±æ€§
                </button>
            </div>

            <!-- æ‰¹é‡æ“ä½œæ  -->
            <div id="batchActionsBar" class="batch-actions-bar" style="display: none;">
                <div class="batch-actions-header">
                    <label class="select-mode-toggle">
                        <input type="checkbox" id="selectModeToggle" onchange="toggleSelectMode()">
                        <span>å¤šé€‰æ¨¡å¼</span>
                    </label>
                    <span id="elementStats" class="element-stats"></span>
                </div>
                <!-- å¤šé€‰æ¨¡å¼ä¸‹çš„æ“ä½œæŒ‰é’® -->
                <div id="batchSelectActions" class="batch-actions-buttons" style="display: none;">
                    <button class="batch-btn batch-btn-small" onclick="selectAllElements()" title="å…¨é€‰">
                        â˜‘ï¸ å…¨é€‰
                    </button>
                    <button class="batch-btn batch-btn-small" onclick="deselectAllElements()" title="å–æ¶ˆå…¨é€‰">
                        â¬œ å–æ¶ˆ
                    </button>
                    <button class="batch-btn" onclick="batchHideSelected()" title="éšè—é€‰ä¸­çš„å…ƒç´ ">
                        ğŸ™ˆ éšè—é€‰ä¸­
                    </button>
                    <button class="batch-btn" onclick="batchShowSelected()" title="æ˜¾ç¤ºé€‰ä¸­çš„å…ƒç´ ">
                        ğŸ‘ï¸ æ˜¾ç¤ºé€‰ä¸­
                    </button>
                </div>
                <!-- å¿«æ·æ“ä½œæŒ‰é’®ï¼ˆéå¤šé€‰æ¨¡å¼ï¼‰ -->
                <div id="batchQuickActions" class="batch-actions-buttons">
                    <button class="batch-btn" onclick="batchShowAll()" title="æ˜¾ç¤ºå…¨éƒ¨å…ƒç´ ">
                        ğŸ‘ï¸ å…¨éƒ¨æ˜¾ç¤º
                    </button>
                    <button class="batch-btn" onclick="batchHideAll()" title="éšè—å…¨éƒ¨å…ƒç´ ">
                        ğŸ™ˆ å…¨éƒ¨éšè—
                    </button>
                    <button class="batch-btn batch-btn-accent" onclick="batchHideUnnamed()" title="åªéšè—æœªå‘½åçš„å…ƒç´ ">
                        ğŸ¯ éšè—æœªå‘½å
                    </button>
                    <button id="aiAutoNameBtn" class="batch-btn batch-btn-ai" title="ä½¿ç”¨ AI è‡ªåŠ¨ä¸ºæœ¬é¡µå…ƒç´ å‘½å">
                        ğŸ¤– AI å‘½åæœ¬é¡µ
                    </button>
                </div>
            </div>

            <!-- å…ƒç´ åˆ—è¡¨è§†å›¾ -->
            <div id="elementListView" class="property-content">
                <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                    è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¡µé¢
                </p>
            </div>

            <!-- ç¼–è¾‘å±æ€§è§†å›¾ -->
            <div id="elementEditView" class="property-content" style="display: none;">
                <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                    è¯·ç‚¹å‡»å·¦ä¾§é¢„è§ˆåŒºçš„å…ƒç´ å¼€å§‹ç¼–è¾‘
                </p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    console.log('ğŸš€ æ¨¡æ¿ç¼–è¾‘å™¨è„šæœ¬å¼€å§‹åŠ è½½...');

    // ========================================
    // Template Editor State
    // ========================================

    let templateEditorState = {
        templateId: null,
        pptPath: null,
        pages: [],
        currentPageNum: 1,
        selectedShapeId: null,  // å½“å‰é€‰ä¸­çš„å…ƒç´ 
        imageCache: new Map()   // å›¾ç‰‡ç¼“å­˜ï¼Œé¿å…é‡å¤åŠ è½½
    };

    // ========================================
    // Utility Functions
    // ========================================

    // Loading overlay
    function showLoading(message = 'å¤„ç†ä¸­...') {
        let overlay = document.getElementById('loadingOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'loadingOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0;
                width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex; flex-direction: column;
                justify-content: center; align-items: center;
                z-index: 9999; color: white; font-size: 1.2rem;
            `;
            overlay.innerHTML = `
                <div style="text-align: center;">
                    <div class="spinner" style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                    <div id="loadingMessage">${message}</div>
                </div>
                <style>
                    @keyframes spin {
                        to { transform: rotate(360deg); }
                    }
                </style>
            `;
            document.body.appendChild(overlay);
        } else {
            overlay.style.display = 'flex';
            document.getElementById('loadingMessage').textContent = message;
        }
    }

    function hideLoading() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    // Toast notifications
    function showToast(message, type = 'info') {
        const colors = {
            success: '#2ecc71',
            error: '#e74c3c',
            warning: '#f39c12',
            info: '#3498db'
        };

        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed; top: 20px; right: 20px;
            background: ${colors[type]}; color: white;
            padding: 1rem 1.5rem; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000; font-size: 1rem;
            animation: slideIn 0.3s ease;
        `;
        toast.innerHTML = `
            <style>
                @keyframes slideIn {
                    from { transform: translateX(400px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            </style>
            ${message}
        `;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    function showSuccess(message) { showToast(message, 'success'); }
    function showError(message) { showToast(message, 'error'); }
    function showWarning(message) { showToast(message, 'warning'); }
    function showInfo(message) { showToast(message, 'info'); }

    // Get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Download JSON
    function downloadJSON(data, filename) {
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    // ========================================
    // å¤šé€‰æ¨¡å¼åŠŸèƒ½
    // ========================================

    // åˆ‡æ¢å¤šé€‰æ¨¡å¼
    function toggleSelectMode() {
        const checkbox = document.getElementById('selectModeToggle');
        templateEditorState.multiSelectMode = checkbox.checked;
        templateEditorState.selectedShapeIds = [];  // æ¸…ç©ºé€‰ä¸­åˆ—è¡¨

        // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
        const selectActions = document.getElementById('batchSelectActions');
        const quickActions = document.getElementById('batchQuickActions');

        if (templateEditorState.multiSelectMode) {
            selectActions.style.display = 'flex';
            quickActions.style.display = 'none';
        } else {
            selectActions.style.display = 'none';
            quickActions.style.display = 'flex';
        }

        renderElementList();
        updateElementStats();
    }

    // åˆ‡æ¢å•ä¸ªå…ƒç´ çš„é€‰ä¸­çŠ¶æ€
    function toggleElementSelection(shapeId) {
        if (!templateEditorState.selectedShapeIds) {
            templateEditorState.selectedShapeIds = [];
        }

        const index = templateEditorState.selectedShapeIds.indexOf(shapeId);
        if (index > -1) {
            templateEditorState.selectedShapeIds.splice(index, 1);
        } else {
            templateEditorState.selectedShapeIds.push(shapeId);
        }

        renderElementList();
        updateElementStats();
    }

    // å…¨é€‰å…ƒç´ 
    function selectAllElements() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        templateEditorState.selectedShapeIds = page.shapes.map(s => s.shape_id);
        renderElementList();
        updateElementStats();
    }

    // å–æ¶ˆå…¨é€‰
    function deselectAllElements() {
        templateEditorState.selectedShapeIds = [];
        renderElementList();
        updateElementStats();
    }

    // éšè—é€‰ä¸­çš„å…ƒç´ 
    async function batchHideSelected() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const selectedIds = templateEditorState.selectedShapeIds || [];
        if (selectedIds.length === 0) {
            showWarning('è¯·å…ˆé€‰æ‹©è¦éšè—çš„å…ƒç´ ');
            return;
        }

        // éšè—é€‰ä¸­çš„å…ƒç´ 
        page.shapes.forEach(s => {
            if (selectedIds.includes(s.shape_id)) {
                s.is_hidden = true;
            }
        });

        await refreshPreviewAfterBatch(page);
        templateEditorState.selectedShapeIds = [];  // æ¸…ç©ºé€‰ä¸­
        showSuccess(`å·²éšè— ${selectedIds.length} ä¸ªå…ƒç´ `);
    }

    // æ˜¾ç¤ºé€‰ä¸­çš„å…ƒç´ 
    async function batchShowSelected() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const selectedIds = templateEditorState.selectedShapeIds || [];
        if (selectedIds.length === 0) {
            showWarning('è¯·å…ˆé€‰æ‹©è¦æ˜¾ç¤ºçš„å…ƒç´ ');
            return;
        }

        // æ˜¾ç¤ºé€‰ä¸­çš„å…ƒç´ 
        page.shapes.forEach(s => {
            if (selectedIds.includes(s.shape_id)) {
                s.is_hidden = false;
            }
        });

        await refreshPreviewAfterBatch(page);
        templateEditorState.selectedShapeIds = [];  // æ¸…ç©ºé€‰ä¸­
        showSuccess(`å·²æ˜¾ç¤º ${selectedIds.length} ä¸ªå…ƒç´ `);
    }

    // ========================================
    // ç¼–è¾‘ä¼šè¯ç®¡ç†
    // ========================================

    // ä¿å­˜ç¼–è¾‘ä¼šè¯åˆ°æœåŠ¡å™¨
    async function saveEditSession() {
        if (!templateEditorState.templateId) return;

        // è®¡ç®—è¿›åº¦æ•°æ®
        let totalCount = 0;
        let namedCount = 0;
        templateEditorState.pages.forEach(page => {
            const visibleShapes = page.shapes.filter(s => !s.is_hidden);
            totalCount += visibleShapes.length;
            namedCount += visibleShapes.filter(s => s.is_named).length;
        });

        // è·å–ç¬¬ä¸€é¡µçš„ç¼©ç•¥å›¾ä½œä¸ºé¢„è§ˆ
        const firstPage = templateEditorState.pages[0];
        const thumbnailUrl = firstPage ? firstPage.image_url : null;

        // ä¿å­˜æ¯ä¸ªå…ƒç´ çš„éšè—çŠ¶æ€ï¼ˆç”¨äºæ¢å¤ï¼‰
        const hiddenShapes = {};
        templateEditorState.pages.forEach(page => {
            const pageHiddenIds = page.shapes
                .filter(s => s.is_hidden)
                .map(s => s.shape_id);
            if (pageHiddenIds.length > 0) {
                hiddenShapes[page.page_num] = pageHiddenIds;
            }
        });

        try {
            await fetch('/developer-tools/edit-sessions/save/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    session_id: templateEditorState.templateId,
                    editor_type: 'ppt',
                    template_name: templateEditorState.templateName || 'æœªå‘½åæ¨¡æ¿',
                    progress_data: {
                        total_count: totalCount,
                        named_count: namedCount,
                        page_count: templateEditorState.pages.length,
                        hidden_shapes: hiddenShapes  // ä¿å­˜éšè—çŠ¶æ€
                    },
                    thumbnail_url: thumbnailUrl
                })
            });
        } catch (e) {
            console.error('ä¿å­˜ç¼–è¾‘ä¼šè¯å¤±è´¥:', e);
        }
    }

    // æ¢å¤ç¼–è¾‘ä¼šè¯
    async function restoreEditSession(sessionId) {
        try {
            showLoading('æ­£åœ¨æ¢å¤ç¼–è¾‘ä¼šè¯...');

            // æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨ï¼Œå¹¶è·å–ä¿å­˜çš„éšè—çŠ¶æ€
            const checkResponse = await fetch(`/developer-tools/edit-sessions/${sessionId}/`);
            const checkData = await checkResponse.json();

            if (!checkResponse.ok || !checkData.exists) {
                hideLoading();
                showError('ç¼–è¾‘ä¼šè¯å·²è¿‡æœŸæˆ–æ–‡ä»¶å·²è¢«åˆ é™¤');
                return false;
            }

            // è·å–ä¿å­˜çš„éšè—çŠ¶æ€ï¼ˆåœ¨ session.progress_data ä¸­ï¼‰
            const hiddenShapes = checkData.session?.progress_data?.hidden_shapes || {};

            // é‡æ–°è§£æ PPT è·å–æ•°æ®
            const pptPath = `/media/template_editor/${sessionId}`;

            // æˆ‘ä»¬éœ€è¦ç›´æ¥åŠ è½½å·²æœ‰çš„æ•°æ®
            // ç”±äº PPT å·²ç»è§£æè¿‡ï¼Œæ•°æ®å­˜å‚¨åœ¨æœåŠ¡å™¨ä¸Š
            // éœ€è¦ä¸€ä¸ª API æ¥è·å–å·²æœ‰ä¼šè¯çš„æ•°æ®
            const response = await fetch(`/developer-tools/restore-session/${sessionId}/`);
            const data = await response.json();

            if (response.ok) {
                templateEditorState.templateId = data.template_id;
                templateEditorState.templateName = data.template_name;
                templateEditorState.pptPath = data.ppt_path;
                templateEditorState.slideWidth = data.slide_width || 12192000;
                templateEditorState.slideHeight = data.slide_height || 6858000;
                templateEditorState.pages = data.pages;
                templateEditorState.currentPageNum = 1;
                templateEditorState.imageCache.clear();

                // æ¢å¤éšè—çŠ¶æ€
                if (Object.keys(hiddenShapes).length > 0) {
                    templateEditorState.pages.forEach(page => {
                        const pageHiddenIds = hiddenShapes[page.page_num] || [];
                        page.shapes.forEach(shape => {
                            if (pageHiddenIds.includes(shape.shape_id)) {
                                shape.is_hidden = true;
                            }
                        });
                    });
                    console.log('[restoreEditSession] å·²æ¢å¤éšè—çŠ¶æ€:', hiddenShapes);
                }

                // æ˜¾ç¤ºç¼–è¾‘å™¨
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('editorSection').style.display = 'flex';

                renderPageList();
                loadPage(1);

                hideLoading();
                showSuccess(`âœ… å·²æ¢å¤ç¼–è¾‘ä¼šè¯ï¼š${data.template_name}`);
                return true;
            } else {
                hideLoading();
                showError('æ¢å¤ä¼šè¯å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                return false;
            }
        } catch (error) {
            hideLoading();
            showError('æ¢å¤ä¼šè¯å¤±è´¥: ' + error.message);
            return false;
        }
    }

    // æ£€æŸ¥ URL ä¸­æ˜¯å¦æœ‰è¦æ¢å¤çš„ä¼šè¯
    function checkRestoreSession() {
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session');
        if (sessionId) {
            restoreEditSession(sessionId);
        }
    }

    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢å¤ä¼šè¯
    checkRestoreSession();

    // ========================================
    // Template Upload
    // ========================================

    const uploadForm = document.getElementById('uploadTemplateForm');
    console.log('ğŸ“‹ è¡¨å•å…ƒç´ :', uploadForm);

    if (uploadForm) {
        uploadForm.addEventListener('submit', async function (e) {
            console.log('ğŸ“¤ è¡¨å•æäº¤äº‹ä»¶è§¦å‘');
            e.preventDefault();

            const formData = new FormData(this);
            const pptFile = formData.get('ppt_file');
            console.log('ğŸ“„ æ–‡ä»¶:', pptFile ? pptFile.name : 'æœªé€‰æ‹©');

            if (!pptFile || pptFile.size === 0) {
                showWarning('è¯·é€‰æ‹© PPT æ–‡ä»¶');
                return;
            }

            // ç¦ç”¨æäº¤æŒ‰é’®
            const submitBtn = this.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'â³ å¤„ç†ä¸­...';

            try {
                console.log('ğŸ”„ å¼€å§‹ä¸Šä¼ ...');
                showLoading('ğŸ“¤ æ­£åœ¨ä¸Šä¼  PPT æ–‡ä»¶...');

                const response = await fetch('/developer-tools/parse-ppt/', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: formData
                });

                console.log('ğŸ“¡ å“åº”çŠ¶æ€:', response.status);
                document.getElementById('loadingMessage').textContent = 'ğŸ”„ æ­£åœ¨ä½¿ç”¨ LibreOffice è½¬æ¢ PDF...';

                const data = await response.json();
                console.log('ğŸ“¦ å“åº”æ•°æ®:', data);

                if (response.ok) {
                    document.getElementById('loadingMessage').textContent = 'ğŸ–¼ï¸ æ­£åœ¨ç”Ÿæˆé¢„è§ˆå›¾ç‰‡...';

                    templateEditorState.templateId = data.template_id;
                    templateEditorState.templateName = pptFile.name;  // ä¿å­˜æ–‡ä»¶å
                    templateEditorState.pptPath = data.ppt_path;
                    // ä¿å­˜å¹»ç¯ç‰‡å°ºå¯¸ï¼ˆç”¨äºæ­£ç¡®è®¡ç®—å…ƒç´ ä½ç½®ï¼‰
                    templateEditorState.slideWidth = data.slide_width || 12192000;
                    templateEditorState.slideHeight = data.slide_height || 6858000;
                    templateEditorState.pages = data.pages;
                    templateEditorState.currentPageNum = 1;
                    templateEditorState.imageCache.clear();

                    // æ˜¾ç¤ºç¼–è¾‘å™¨
                    document.getElementById('uploadSection').style.display = 'none';
                    document.getElementById('editorSection').style.display = 'flex';

                    // æ¸²æŸ“é¡µé¢åˆ—è¡¨
                    renderPageList();

                    // åŠ è½½ç¬¬ä¸€é¡µ
                    loadPage(1);

                    // ä¿å­˜ç¼–è¾‘ä¼šè¯
                    saveEditSession();

                    hideLoading();
                    showSuccess(`âœ… æ¨¡æ¿è§£ææˆåŠŸï¼å…± ${data.pages.length} é¡µï¼Œä½¿ç”¨æ‡’åŠ è½½æå‡é€Ÿåº¦`);
                } else {
                    hideLoading();
                    showError('âŒ è§£æå¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                hideLoading();
                showError('âŒ ä¸Šä¼ å¤±è´¥: ' + error.message);
                console.error('Upload error:', error);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });
        console.log('âœ… è¡¨å•äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š');
    } else {
        console.error('âŒ æœªæ‰¾åˆ°è¡¨å•å…ƒç´  #uploadTemplateForm');
    }

    // ========================================
    // File Input Display
    // ========================================

    const fileInput = document.getElementById('pptFileInput');
    const fileNameDisplay = document.getElementById('fileNameDisplay');

    if (fileInput && fileNameDisplay) {
        fileInput.addEventListener('change', function () {
            if (this.files && this.files[0]) {
                fileNameDisplay.textContent = 'ğŸ“„ ' + this.files[0].name;
                fileNameDisplay.style.color = 'var(--success-color)';
            } else {
                fileNameDisplay.textContent = 'ğŸ“ ç‚¹å‡»é€‰æ‹© PPT æ–‡ä»¶';
                fileNameDisplay.style.color = '';
            }
        });
    }

    // ========================================
    // Page List Rendering
    // ========================================

    function renderPageList() {
        const pageList = document.getElementById('pageList');
        pageList.innerHTML = '';

        templateEditorState.pages.forEach((page, index) => {
            const totalShapes = page.shapes.filter(s => !s.is_hidden).length;
            const namedShapes = page.shapes.filter(s => !s.is_hidden && s.is_named).length;
            const percent = totalShapes > 0 ? Math.round(namedShapes / totalShapes * 100) : 0;

            const pageItem = document.createElement('div');
            pageItem.className = 'page-item' + (page.page_num === templateEditorState.currentPageNum ? ' active' : '');
            pageItem.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <span style="font-weight: bold;">ç¬¬ ${page.page_num} é¡µ</span>
                    <span style="font-size: 0.85rem; color: ${percent === 100 ? 'var(--success-color)' : 'var(--text-secondary)'};">
                        ${percent}%
                    </span>
                </div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                    ${namedShapes} / ${totalShapes} å·²å‘½å
                </div>
                <div style="height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden;">
                    <div style="height: 100%; background: var(--success-color); width: ${percent}%; transition: width 0.3s ease;"></div>
                </div>
            `;
            pageItem.onclick = () => loadPage(page.page_num);
            pageList.appendChild(pageItem);
        });
    }

    // ========================================
    // Page Loading (Lazy Loading + Caching)
    // ========================================

    function loadPage(pageNum) {
        const page = templateEditorState.pages.find(p => p.page_num === pageNum);
        if (!page) return;

        templateEditorState.currentPageNum = pageNum;

        // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
        templateEditorState.selectedShapeId = null;

        // åˆ‡æ¢åˆ°å…ƒç´ åˆ—è¡¨è§†å›¾ï¼ˆè€Œä¸æ˜¯ç¼–è¾‘è§†å›¾ï¼‰
        switchPropertyTab('list');

        // æ¸…ç©ºç¼–è¾‘é¢æ¿
        document.getElementById('elementEditView').innerHTML = `
            <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                è¯·ä»å·¦ä¾§åˆ—è¡¨é€‰æ‹©ä¸€ä¸ªå…ƒç´ è¿›è¡Œç¼–è¾‘
            </p>
        `;

        // æ›´æ–°é¡µé¢æ ‡é¢˜
        document.getElementById('currentPageTitle').textContent = `ç¬¬ ${pageNum} é¡µ`;

        // æ›´æ–°é¡µé¢åˆ—è¡¨é«˜äº®
        document.querySelectorAll('#pageList .page-item').forEach((item, index) => {
            item.classList.toggle('active', index + 1 === pageNum);
        });

        // æ£€æŸ¥ç¼“å­˜
        if (templateEditorState.imageCache.has(page.image_url)) {
            renderCanvas(page);
            return;
        }

        // æ˜¾ç¤ºåŠ è½½æç¤º
        showLoading(`ğŸ–¼ï¸ æ­£åœ¨åŠ è½½ç¬¬ ${pageNum} é¡µé¢„è§ˆå›¾ç‰‡...`);

        // æ‡’åŠ è½½å›¾ç‰‡
        const img = new Image();
        img.onload = () => {
            templateEditorState.imageCache.set(page.image_url, img);
            renderCanvas(page);
            hideLoading();
        };

        img.onerror = () => {
            hideLoading();
            showError(`åŠ è½½ç¬¬ ${pageNum} é¡µå›¾ç‰‡å¤±è´¥`);
        };

        img.src = page.image_url;
    }

    // ========================================
    // å›¾ç‰‡é¢„è§ˆæ¸²æŸ“
    // ========================================

    function renderCanvas(page) {
        // ç®€å•åœ°è®¾ç½®å›¾ç‰‡ URLï¼ˆåç«¯å·²ç”Ÿæˆå¸¦æ ‡æ³¨çš„å›¾ç‰‡ï¼‰
        const previewImage = document.getElementById('previewImage');
        previewImage.src = page.image_url;

        // æ¸²æŸ“å…ƒç´ åˆ—è¡¨
        renderElementList();

        // æ›´æ–°è¿›åº¦
        updateProgress();

        // é¢„åŠ è½½ä¸‹ä¸€é¡µ
        preloadNextPage(page.page_num);
    }

    // é¢„åŠ è½½ä¸‹ä¸€é¡µå›¾ç‰‡
    function preloadNextPage(currentPageNum) {
        const nextPage = templateEditorState.pages.find(p => p.page_num === currentPageNum + 1);
        if (!nextPage) return;

        if (templateEditorState.imageCache.has(nextPage.image_url)) return;

        const img = new Image();
        img.onload = () => {
            templateEditorState.imageCache.set(nextPage.image_url, img);
            console.log(`âœ… é¢„åŠ è½½ç¬¬ ${nextPage.page_num} é¡µå®Œæˆ`);
        };
        img.onerror = () => {
            console.warn(`âš ï¸ é¢„åŠ è½½ç¬¬ ${nextPage.page_num} é¡µå¤±è´¥`);
        };
        img.src = nextPage.image_url;
    }

    // ========================================
    // Property Panel
    // ========================================

    // Switch property tabs
    function switchPropertyTab(tab) {
        const tabs = document.querySelectorAll('.property-tab');
        const listView = document.getElementById('elementListView');
        const editView = document.getElementById('elementEditView');

        if (tab === 'list') {
            tabs[0].classList.add('active');
            tabs[1].classList.remove('active');
            listView.style.display = 'block';
            editView.style.display = 'none';
        } else {
            tabs[0].classList.remove('active');
            tabs[1].classList.add('active');
            listView.style.display = 'none';
            editView.style.display = 'block';
        }
    }

    // Render element list
    function renderElementList() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const listView = document.getElementById('elementListView');
        const batchActionsBar = document.getElementById('batchActionsBar');

        if (page.shapes.length === 0) {
            listView.innerHTML = `
                <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                    è¯¥é¡µé¢æ²¡æœ‰å¯ç¼–è¾‘çš„å…ƒç´ 
                </p>
            `;
            if (batchActionsBar) batchActionsBar.style.display = 'none';
            return;
        }

        // æ˜¾ç¤ºæ‰¹é‡æ“ä½œæ 
        if (batchActionsBar) {
            batchActionsBar.style.display = 'block';
            updateElementStats();
        }

        const isMultiSelectMode = templateEditorState.multiSelectMode || false;
        let html = '';
        let visibleIndex = 0;  // ç”¨äºæ˜¾ç¤ºå¯è§å…ƒç´ çš„ç¼–å·

        page.shapes.forEach((shape) => {
            const isHidden = shape.is_hidden;
            const isNamed = shape.is_named;
            const isSelected = templateEditorState.selectedShapeId === shape.shape_id;
            const isMultiSelected = templateEditorState.selectedShapeIds?.includes(shape.shape_id) || false;

            // åªç»™å¯è§å…ƒç´ åˆ†é…ç¼–å·
            if (!isHidden) {
                visibleIndex++;
            }

            // æ˜¾ç¤ºæ–‡æœ¬é¢„è§ˆï¼ˆæˆªæ–­ï¼‰
            const textPreview = shape.text_sample
                ? (shape.text_sample.length > 30 ? shape.text_sample.substring(0, 30) + '...' : shape.text_sample)
                : '';

            // éšè—å…ƒç´ æ˜¾ç¤ºä¸ºç°è‰²æ ·å¼
            const hiddenStyle = isHidden ? 'opacity: 0.5; background: #f5f5f5;' : '';
            const nameStyle = isHidden ? 'color: #999; text-decoration: line-through;' : (isNamed ? '' : 'color: var(--warning-color);');

            // å¤šé€‰æ¨¡å¼ä¸‹çš„ç±»åå’Œç‚¹å‡»äº‹ä»¶
            const multiSelectClass = isMultiSelectMode ? 'multi-select-mode' : '';
            const multiSelectedClass = isMultiSelected ? 'multi-selected' : '';
            const clickHandler = isMultiSelectMode
                ? `toggleElementSelection(${shape.shape_id})`
                : `selectElement(${shape.shape_id})`;

            html += `
                <div class="element-item ${isNamed ? '' : 'unnamed'} ${isSelected && !isMultiSelectMode ? 'selected' : ''} ${isHidden ? 'hidden-element' : ''} ${multiSelectClass} ${multiSelectedClass}"
                     style="${hiddenStyle}"
                     onclick="${clickHandler}">
                    <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
                        ${isMultiSelectMode ? `
                            <input type="checkbox" class="element-checkbox"
                                   ${isMultiSelected ? 'checked' : ''}
                                   onclick="event.stopPropagation(); toggleElementSelection(${shape.shape_id})">
                        ` : ''}
                        <span class="element-number" style="${isHidden ? 'background: #ccc; color: #999;' : ''}">
                            ${isHidden ? 'â€”' : visibleIndex}
                        </span>
                        <div style="flex: 1; min-width: 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 600; ${nameStyle}">
                                    ${shape.name || 'æœªå‘½å'}
                                </span>
                                <span style="font-size: 0.75rem; padding: 0.125rem 0.5rem; background: ${isHidden ? '#eee' : 'var(--bg-color)'}; border-radius: 12px; ${isHidden ? 'color: #999;' : ''}">
                                    ${isHidden ? 'ğŸ™ˆ å·²éšè—' : (shape.type === 'text' ? 'ğŸ“ æ–‡æœ¬' : 'ğŸ–¼ï¸ å›¾ç‰‡')}
                                </span>
                            </div>
                            ${textPreview ? `<div style="font-size: 0.8rem; color: ${isHidden ? '#bbb' : 'var(--text-secondary)'}; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${textPreview}</div>` : ''}
                        </div>
                    </div>
                </div>
            `;
        });

        listView.innerHTML = html;
    }

    // Select element from list
    function selectElement(shapeId) {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const shape = page.shapes.find(s => s.shape_id === shapeId);

        if (shape) {
            templateEditorState.selectedShapeId = shapeId;
            renderElementList();
            switchPropertyTab('edit');
            renderPropertyPanel(shape);
        }
    }

    // Render property panel
    function renderPropertyPanel(shape) {
        const panel = document.getElementById('elementEditView');

        const shapeIndex = templateEditorState.pages
            .find(p => p.page_num === templateEditorState.currentPageNum)
            .shapes.findIndex(s => s.shape_id === shape.shape_id) + 1;

        panel.innerHTML = `
            <div style="margin-bottom: var(--spacing-lg);">
                <h4 style="margin-bottom: var(--spacing-md);">å…ƒç´  #${shapeIndex}</h4>

                <div class="form-group">
                    <label class="form-label">ç±»å‹</label>
                    <div style="padding: 0.5rem; background: var(--bg-color); border-radius: var(--radius-sm);">
                        ${shape.type === 'text' ? 'ğŸ“ æ–‡æœ¬æ¡†' : 'ğŸ–¼ï¸ å›¾ç‰‡'}
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label required">å…ƒç´ åç§°</label>
                    <input type="text" id="shapeNameInput" class="text-input"
                           value="${shape.name || ''}"
                           placeholder="ä¾‹å¦‚ï¼šæ ‡é¢˜åŒºã€ä½œè€…åã€ä¸»è¦å†…å®¹">
                    <small class="form-help">ä½¿ç”¨è¯­ä¹‰åŒ–åç§°ï¼Œæ–¹ä¾¿åç»­é…ç½®</small>
                </div>

                <div class="form-group">
                    <label class="form-label">ä½ç½®å’Œå°ºå¯¸</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85rem;">
                        <div style="padding: 0.5rem; background: var(--bg-color); border-radius: var(--radius-sm);">
                            <div style="color: var(--text-secondary);">X</div>
                            <div>${Math.round(shape.left / 914400 * 2.54 * 10) / 10} cm</div>
                        </div>
                        <div style="padding: 0.5rem; background: var(--bg-color); border-radius: var(--radius-sm);">
                            <div style="color: var(--text-secondary);">Y</div>
                            <div>${Math.round(shape.top / 914400 * 2.54 * 10) / 10} cm</div>
                        </div>
                        <div style="padding: 0.5rem; background: var(--bg-color); border-radius: var(--radius-sm);">
                            <div style="color: var(--text-secondary);">å®½åº¦</div>
                            <div>${Math.round(shape.width / 914400 * 2.54 * 10) / 10} cm</div>
                        </div>
                        <div style="padding: 0.5rem; background: var(--bg-color); border-radius: var(--radius-sm);">
                            <div style="color: var(--text-secondary);">é«˜åº¦</div>
                            <div>${Math.round(shape.height / 914400 * 2.54 * 10) / 10} cm</div>
                        </div>
                    </div>
                </div>

                <div class="form-actions">
                    <button class="btn btn-primary btn-block" onclick="saveShapeName(${shape.shape_id})">
                        ğŸ’¾ ä¿å­˜åç§°
                    </button>
                    <button class="btn btn-${shape.is_hidden ? 'success' : 'secondary'} btn-block"
                            onclick="toggleShapeVisibility(${shape.shape_id})">
                        ${shape.is_hidden ? 'ğŸ‘ï¸ æ˜¾ç¤ºå…ƒç´ ' : 'ğŸ™ˆ éšè—å…ƒç´ '}
                    </button>
                </div>
            </div>
        `;
    }

    // ========================================
    // Element Actions
    // ========================================

    // Save shape name
    async function saveShapeName(shapeId) {
        const newName = document.getElementById('shapeNameInput').value.trim();

        if (!newName) {
            showWarning('è¯·è¾“å…¥å…ƒç´ åç§°');
            return;
        }

        // æ‰¾åˆ°å¯¹åº”çš„ shape
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const shape = page.shapes.find(s => s.shape_id === shapeId);

        if (!shape) {
            showError('æ‰¾ä¸åˆ°å…ƒç´ ');
            return;
        }

        try {
            const response = await fetch('/developer-tools/update-shape-name/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shape_id: shape.shape_id,  // ä½¿ç”¨ shape_id æ”¯æŒ GROUP å†…å…ƒç´ 
                    new_name: newName
                })
            });

            const data = await response.json();

            if (response.ok) {
                shape.name = newName;
                shape.is_named = true;

                renderElementList();
                renderPageList();
                updateProgress();
                renderPropertyPanel(shape);

                // æ›´æ–°ç¼–è¾‘ä¼šè¯è¿›åº¦
                saveEditSession();

                showSuccess('âœ… åç§°å·²ä¿å­˜');
            } else {
                showError('ä¿å­˜å¤±è´¥: ' + data.error);
            }
        } catch (error) {
            showError('ä¿å­˜å¤±è´¥: ' + error.message);
        }
    }

    // Toggle shape visibility
    async function toggleShapeVisibility(shapeId) {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const shape = page.shapes.find(s => s.shape_id === shapeId);

        if (!shape) return;

        const newHiddenState = !shape.is_hidden;

        try {
            // 1. æ›´æ–°å‰ç«¯çŠ¶æ€
            shape.is_hidden = newHiddenState;

            // 2. é€šçŸ¥åç«¯ï¼ˆå¯é€‰ï¼Œç”¨äºæŒä¹…åŒ–ï¼‰
            await fetch('/developer-tools/toggle-shape-visibility/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shape_id: shape.shape_id,
                    is_hidden: newHiddenState
                })
            });

            // 3. åˆ·æ–°é¢„è§ˆå›¾ï¼ˆæ›´æ–°æ ‡æ³¨ï¼‰
            console.log('[toggleShapeVisibility] åˆ·æ–°é¢„è§ˆå›¾, shapes:', page.shapes.map(s => ({
                name: s.name,
                shape_id: s.shape_id,
                is_hidden: s.is_hidden
            })));

            const previewResponse = await fetch('/developer-tools/refresh-preview/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shapes: page.shapes  // ä¼ å…¥å®Œæ•´çš„ shapes åˆ—è¡¨ï¼ˆåŒ…å« is_hidden çŠ¶æ€ï¼‰
                })
            });

            const previewData = await previewResponse.json();
            console.log('[toggleShapeVisibility] é¢„è§ˆå›¾å“åº”:', previewData);

            if (previewResponse.ok && previewData.image_url) {
                // æ›´æ–°é¢„è§ˆå›¾
                const newImageUrl = previewData.image_url + '?t=' + Date.now();  // åŠ æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
                console.log('[toggleShapeVisibility] æ›´æ–°é¢„è§ˆå›¾:', newImageUrl);
                page.image_url = newImageUrl;
                document.getElementById('previewImage').src = newImageUrl;
            } else {
                console.error('[toggleShapeVisibility] åˆ·æ–°é¢„è§ˆå›¾å¤±è´¥:', previewData);
            }

            // 4. æ›´æ–° UI
            renderElementList();
            renderPageList();
            renderPropertyPanel(shape);
            updateProgress();

            // 5. ä¿å­˜ç¼–è¾‘ä¼šè¯ï¼ˆæŒä¹…åŒ–éšè—çŠ¶æ€ï¼‰
            saveEditSession();

            showSuccess(newHiddenState ? 'å…ƒç´ å·²éšè—' : 'å…ƒç´ å·²æ˜¾ç¤º');
        } catch (error) {
            // å›æ»šçŠ¶æ€
            shape.is_hidden = !newHiddenState;
            showError('æ“ä½œå¤±è´¥: ' + error.message);
        }
    }

    // Update progress
    function updateProgress() {
        let totalShapes = 0;
        let namedShapes = 0;

        templateEditorState.pages.forEach(page => {
            page.shapes.forEach(shape => {
                if (!shape.is_hidden) {
                    totalShapes++;
                    if (shape.is_named) {
                        namedShapes++;
                    }
                }
            });
        });

        const percent = totalShapes > 0 ? Math.round(namedShapes / totalShapes * 100) : 0;
        document.getElementById('namedCount').textContent = `${namedShapes} / ${totalShapes}`;
        document.getElementById('progressBar').style.width = percent + '%';
        document.getElementById('progressPercent').textContent = percent + '%';

        // æ›´æ–°å½“å‰é¡µçš„å…ƒç´ ç»Ÿè®¡
        updateElementStats();
    }

    // æ›´æ–°å…ƒç´ ç»Ÿè®¡ä¿¡æ¯
    function updateElementStats() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const statsEl = document.getElementById('elementStats');
        if (!page || !statsEl) return;

        const total = page.shapes.length;
        const visible = page.shapes.filter(s => !s.is_hidden).length;
        const named = page.shapes.filter(s => !s.is_hidden && s.is_named).length;
        const selectedCount = templateEditorState.selectedShapeIds?.length || 0;

        if (templateEditorState.multiSelectMode && selectedCount > 0) {
            statsEl.textContent = `å·²é€‰ ${selectedCount} | æ˜¾ç¤º ${visible}/${total}`;
            statsEl.style.background = 'rgba(52, 152, 219, 0.2)';
            statsEl.style.color = 'var(--primary-color)';
        } else {
            statsEl.textContent = `æ˜¾ç¤º ${visible}/${total} | å·²å‘½å ${named}`;
            statsEl.style.background = 'white';
            statsEl.style.color = 'var(--text-secondary)';
        }
    }

    // ========================================
    // æ‰¹é‡æ“ä½œåŠŸèƒ½
    // ========================================

    // æ‰¹é‡æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
    async function batchShowAll() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const hiddenShapes = page.shapes.filter(s => s.is_hidden);
        if (hiddenShapes.length === 0) {
            showInfo('æ²¡æœ‰éšè—çš„å…ƒç´ ');
            return;
        }

        await batchUpdateVisibility(page, page.shapes, false);
        showSuccess(`å·²æ˜¾ç¤º ${hiddenShapes.length} ä¸ªå…ƒç´ `);
    }

    // æ‰¹é‡éšè—æ‰€æœ‰å…ƒç´ 
    async function batchHideAll() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) {
            showInfo('æ²¡æœ‰å¯éšè—çš„å…ƒç´ ');
            return;
        }

        await batchUpdateVisibility(page, page.shapes, true);
        showSuccess(`å·²éšè— ${visibleShapes.length} ä¸ªå…ƒç´ `);
    }

    // æ‰¹é‡éšè—æœªå‘½åå…ƒç´ 
    async function batchHideUnnamed() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const unnamedShapes = page.shapes.filter(s => !s.is_named && !s.is_hidden);
        if (unnamedShapes.length === 0) {
            showInfo('æ²¡æœ‰æœªå‘½åçš„å¯è§å…ƒç´ ');
            return;
        }

        // åªéšè—æœªå‘½åçš„å…ƒç´ 
        unnamedShapes.forEach(s => s.is_hidden = true);
        await refreshPreviewAfterBatch(page);
        showSuccess(`å·²éšè— ${unnamedShapes.length} ä¸ªæœªå‘½åå…ƒç´ `);
    }

    // æ‰¹é‡æ›´æ–°å¯è§æ€§
    async function batchUpdateVisibility(page, shapes, isHidden) {
        shapes.forEach(s => s.is_hidden = isHidden);
        await refreshPreviewAfterBatch(page);
    }

    // æ‰¹é‡æ“ä½œååˆ·æ–°é¢„è§ˆ
    async function refreshPreviewAfterBatch(page) {
        try {
            const previewResponse = await fetch('/developer-tools/refresh-preview/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shapes: page.shapes
                })
            });

            const previewData = await previewResponse.json();

            if (previewResponse.ok && previewData.image_url) {
                const newImageUrl = previewData.image_url + '?t=' + Date.now();
                page.image_url = newImageUrl;
                document.getElementById('previewImage').src = newImageUrl;
            }

            // æ›´æ–° UI
            renderElementList();
            renderPageList();
            updateProgress();

            // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            templateEditorState.selectedShapeId = null;
            switchPropertyTab('list');

            // ä¿å­˜ç¼–è¾‘ä¼šè¯ï¼ˆæŒä¹…åŒ–éšè—çŠ¶æ€ï¼‰
            saveEditSession();

        } catch (error) {
            showError('åˆ·æ–°é¢„è§ˆå¤±è´¥: ' + error.message);
        }
    }

    // ========================================
    // Toolbar Actions
    // ========================================

    // å›¾ç‰‡ç¼©æ”¾çŠ¶æ€
    let imageZoom = 100;

    // Zoom controls
    document.getElementById('zoomInBtn')?.addEventListener('click', () => {
        imageZoom = Math.min(200, imageZoom + 25);
        updateImageZoom();
    });

    document.getElementById('zoomOutBtn')?.addEventListener('click', () => {
        imageZoom = Math.max(25, imageZoom - 25);
        updateImageZoom();
    });

    document.getElementById('fitToWindowBtn')?.addEventListener('click', () => {
        imageZoom = 100;
        updateImageZoom();
    });

    function updateImageZoom() {
        const img = document.getElementById('previewImage');
        if (img) {
            img.style.transform = `scale(${imageZoom / 100})`;
            img.style.transformOrigin = 'center center';
        }
        document.getElementById('zoomLevel').textContent = imageZoom + '%';
    }

    // Upload new template
    document.getElementById('uploadNewBtn')?.addEventListener('click', () => {
        document.getElementById('uploadSection').style.display = 'block';
        document.getElementById('editorSection').style.display = 'none';
        document.getElementById('uploadTemplateForm').reset();
    });

    // AI å‘½åçŠ¶æ€æ ‡å¿—ï¼ˆé˜²æ­¢é‡å¤ç‚¹å‡»ï¼‰
    let isAINaming = false;

    // AI å‘½åå•ä¸ªé¡µé¢çš„æ ¸å¿ƒå‡½æ•°
    async function aiNamePage(page, showProgress = true) {
        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) {
            return { success: true, count: 0, skipped: true };
        }

        try {
            const response = await fetch('/developer-tools/ai-auto-name/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: page.page_num,
                    image_url: page.image_url,
                    shapes: page.shapes
                })
            });

            const data = await response.json();

            if (!response.ok) {
                return { success: false, error: data.error || 'æœªçŸ¥é”™è¯¯' };
            }

            // åº”ç”¨ AI å»ºè®®çš„åç§°ï¼ˆä¸²è¡Œä¿å­˜ï¼Œé¿å…å¹¶å‘ï¼‰
            const namedShapes = data.named_shapes || [];
            let successCount = 0;

            for (let i = 0; i < namedShapes.length; i++) {
                const suggestion = namedShapes[i];
                const shape = page.shapes.find(s => s.shape_index === suggestion.shape_index);
                if (shape && suggestion.suggested_name) {
                    shape.name = suggestion.suggested_name;
                    shape.is_named = true;

                    try {
                        await fetch('/developer-tools/update-shape-name/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': getCookie('csrftoken')
                            },
                            body: JSON.stringify({
                                template_id: templateEditorState.templateId,
                                page_num: page.page_num,
                                shape_index: suggestion.shape_index,
                                new_name: suggestion.suggested_name
                            })
                        });
                        successCount++;

                        // çŸ­å»¶è¿Ÿé¿å…è§¦å‘åç«¯é™æµï¼ˆæ¯ä¿å­˜ä¸€ä¸ªç­‰50msï¼‰
                        if (i < namedShapes.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    } catch (e) {
                        console.error('ä¿å­˜å¤±è´¥:', suggestion, e);
                    }
                }
            }

            return { success: true, count: successCount };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    // AI å‘½åæœ¬é¡µ
    document.getElementById('aiAutoNameBtn')?.addEventListener('click', async () => {
        if (isAINaming) {
            showWarning('AI æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...');
            return;
        }

        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) {
            showWarning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¡µé¢');
            return;
        }

        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) {
            showWarning('å½“å‰é¡µé¢æ²¡æœ‰å¯å‘½åçš„å…ƒç´ ');
            return;
        }

        isAINaming = true;
        showLoading('ğŸ¤– AI æ­£åœ¨åˆ†æå½“å‰é¡µé¢å…ƒç´ ...');

        try {
            const result = await aiNamePage(page);
            hideLoading();

            if (result.success) {
                renderElementList();
                renderPageList();
                updateProgress();
                showSuccess(`âœ… AI æˆåŠŸå‘½å ${result.count} ä¸ªå…ƒç´ `);
            } else {
                showError('AI å‘½åå¤±è´¥: ' + result.error);
            }
        } finally {
            isAINaming = false;
        }
    });

    // AI å‘½åå…¨éƒ¨é¡µé¢ï¼ˆé€é¡µä¸²è¡Œå¤„ç†ï¼Œé¿å…å¹¶å‘é™åˆ¶ï¼‰
    document.getElementById('aiAutoNameAllBtn')?.addEventListener('click', async () => {
        if (isAINaming) {
            showWarning('AI æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...');
            return;
        }

        // ç­›é€‰éœ€è¦å‘½åçš„é¡µé¢ï¼ˆæœ‰å¯è§å…ƒç´ ä¸”æœªå®Œæˆå‘½åçš„ï¼‰
        const pagesToName = templateEditorState.pages.filter(p => {
            const visibleShapes = p.shapes.filter(s => !s.is_hidden);
            const namedCount = visibleShapes.filter(s => s.is_named).length;
            return visibleShapes.length > 0 && namedCount < visibleShapes.length;
        });

        if (pagesToName.length === 0) {
            showWarning('æ‰€æœ‰é¡µé¢å·²å®Œæˆå‘½å');
            return;
        }

        if (!confirm(`ç¡®å®šè¦ä½¿ç”¨ AI å‘½å ${pagesToName.length} ä¸ªæœªå®Œæˆçš„é¡µé¢å—ï¼Ÿ\n\nè¿™å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚`)) {
            return;
        }

        isAINaming = true;
        let totalSuccess = 0;
        let totalFailed = 0;

        for (let i = 0; i < pagesToName.length; i++) {
            const page = pagesToName[i];
            showLoading(`ğŸ¤– AI æ­£åœ¨å¤„ç†ç¬¬ ${page.page_num} é¡µ (${i + 1}/${pagesToName.length})...`);

            const result = await aiNamePage(page, false);

            if (result.success) {
                totalSuccess += result.count;
            } else {
                totalFailed++;
                console.error(`ç¬¬ ${page.page_num} é¡µå‘½åå¤±è´¥:`, result.error);
            }

            // æ›´æ–° UI
            renderPageList();
            updateProgress();

            // å»¶è¿Ÿé¿å… API é™æµï¼ˆGLM ç­‰ API å¯¹å¹¶å‘è¦æ±‚ä¸¥æ ¼ï¼‰
            if (i < pagesToName.length - 1) {
                showLoading(`â³ ç­‰å¾… 3 ç§’é¿å… API é™æµ...`);
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
        }

        hideLoading();
        isAINaming = false;

        // åˆ·æ–°å½“å‰é¡µé¢çš„å…ƒç´ åˆ—è¡¨
        renderElementList();

        if (totalFailed === 0) {
            showSuccess(`âœ… AI æ‰¹é‡å‘½åå®Œæˆï¼å…±å‘½å ${totalSuccess} ä¸ªå…ƒç´ `);
        } else {
            showWarning(`âš ï¸ æ‰¹é‡å‘½åå®Œæˆï¼ŒæˆåŠŸ ${totalSuccess} ä¸ªå…ƒç´ ï¼Œ${totalFailed} ä¸ªé¡µé¢å¤±è´¥`);
        }
    });

    // Save PPT
    document.getElementById('saveTemplateBtn')?.addEventListener('click', async () => {
        if (!templateEditorState.templateId) {
            showWarning('æ²¡æœ‰å¯ä¿å­˜çš„æ¨¡æ¿');
            return;
        }

        try {
            showLoading('æ­£åœ¨ä¿å­˜ PPT...');

            const url = `/developer-tools/download-ppt/${templateEditorState.templateId}/`;
            const a = document.createElement('a');
            a.href = url;
            a.download = 'template.pptx';
            a.click();

            hideLoading();
            showSuccess('PPT å·²ä¿å­˜ï¼');
        } catch (error) {
            hideLoading();
            showError('ä¿å­˜å¤±è´¥: ' + error.message);
        }
    });

    // Generate config JSON
    document.getElementById('generateConfigBtn')?.addEventListener('click', async () => {
        if (!templateEditorState.templateId) {
            showWarning('æ²¡æœ‰å¯ç”Ÿæˆçš„é…ç½®');
            return;
        }

        try {
            showLoading('æ­£åœ¨ç”Ÿæˆé…ç½® JSON...');

            const response = await fetch('/developer-tools/generate-config/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId
                })
            });

            const data = await response.json();

            if (response.ok) {
                downloadJSON(data.config, 'template_config.json');
                hideLoading();
                showSuccess('é…ç½® JSON å·²ç”Ÿæˆï¼');
            } else {
                hideLoading();
                showError('ç”Ÿæˆå¤±è´¥: ' + data.error);
            }
        } catch (error) {
            hideLoading();
            showError('ç”Ÿæˆå¤±è´¥: ' + error.message);
        }
    });

    // ========================================
    // Keyboard Shortcuts
    // ========================================

    document.addEventListener('keydown', function (e) {
        // Ignore if typing in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        // Ctrl+S: Save PPT
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            document.getElementById('saveTemplateBtn')?.click();
        }

        // Ctrl+G: Generate config
        if (e.ctrlKey && e.key === 'g') {
            e.preventDefault();
            document.getElementById('generateConfigBtn')?.click();
        }

        // Arrow keys: Switch pages
        if (e.key === 'ArrowLeft') {
            const prevPage = templateEditorState.currentPageNum - 1;
            if (prevPage >= 1) {
                loadPage(prevPage);
            }
        }
        if (e.key === 'ArrowRight') {
            const nextPage = templateEditorState.currentPageNum + 1;
            if (nextPage <= templateEditorState.pages.length) {
                loadPage(nextPage);
            }
        }

        // +/-: Zoom
        if (e.key === '+' || e.key === '=') {
            e.preventDefault();
            imageZoom = Math.min(200, imageZoom + 25);
            updateImageZoom();
        }
        if (e.key === '-') {
            e.preventDefault();
            imageZoom = Math.max(25, imageZoom - 25);
            updateImageZoom();
        }

        // 0: Fit to window
        if (e.key === '0') {
            e.preventDefault();
            imageZoom = 100;
            updateImageZoom();
        }
    });

    // ========================================
    // File Upload UI Enhancement
    // ========================================

    document.getElementById('ppt_file')?.addEventListener('change', function () {
        const label = this.nextElementSibling;
        if (this.files.length > 0) {
            label.textContent = this.files[0].name;
        }
    });

    // ========================================
    // Property Tab Switching
    // ========================================

    document.querySelectorAll('.property-tab').forEach((tab, index) => {
        tab.addEventListener('click', () => {
            switchPropertyTab(index === 0 ? 'list' : 'edit');
        });
    });
</script>
{% endblock %}