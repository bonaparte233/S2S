{% extends 'base.html' %}
{% load static %}

{% block title %}PPT æ¨¡æ¿ç¼–è¾‘å™¨ - S2S{% endblock %}

{% block extra_css %}
<style>
    /* æ¨¡æ¿ç¼–è¾‘å™¨å…¨å±å¸ƒå±€ */
    html,
    body {
        height: 100%;
        margin: 0;
        overflow: hidden;
    }

    /* éšè—ä¸»é¡µå¯¼èˆªæ ï¼Œç¼–è¾‘å™¨æœ‰è‡ªå·±çš„é¡¶æ  */
    .navbar {
        display: none !important;
    }

    /* è¦†ç›– base.html ä¸­çš„å®¹å™¨æ ·å¼ */
    .main-content {
        padding: 0 !important;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    .main-content>.container {
        max-width: 100% !important;
        padding: 0 !important;
        margin: 0 !important;
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    .footer {
        display: none !important;
    }

    /* åµŒå…¥æ¨¡å¼æ ·å¼ - éšè—æ‰€æœ‰é¡¶æ æŒ‰é’® */
    .embedded-mode #uploadSection {
        display: none !important;
    }

    .embedded-mode .editor-toolbar {
        display: none !important;
    }

    /* å…¨å±ç¼–è¾‘å™¨å®¹å™¨ */
    .template-editor-fullscreen-container {
        flex: 1;
        background: var(--bg-color);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    /* é¡¶éƒ¨å·¥å…·æ  */
    .editor-toolbar {
        height: 70px;
        background: white;
        border-bottom: 1px solid var(--border-color);
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        padding: 0 var(--spacing-xl);
        flex-shrink: 0;
    }

    .editor-toolbar>div:first-child {
        justify-self: start;
    }

    .editor-toolbar h2 {
        margin: 0;
        font-size: 1.4rem;
        color: var(--text-primary);
        text-align: center;
    }

    .editor-toolbar>div:last-child {
        justify-self: end;
    }

    .toolbar-actions {
        display: flex;
        gap: var(--spacing-sm);
    }

    /* ä¸»ç¼–è¾‘åŒºåŸŸ */
    .editor-main {
        flex: 1;
        display: flex;
        overflow: hidden;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    /* å·¦ä¾§é¡µé¢åˆ—è¡¨ */
    .editor-sidebar-left {
        width: 220px;
        background: white;
        border-right: 1px solid var(--border-color);
        overflow-y: auto;
        flex-shrink: 0;
    }

    /* ä¸­é—´ Canvas é¢„è§ˆåŒº */
    .editor-canvas-area {
        flex: 1;
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    .canvas-toolbar {
        height: 50px;
        background: white;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 var(--spacing-md);
        flex-shrink: 0;
    }

    .canvas-container {
        flex: 1;
        overflow: auto;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 0;
        /* é‡è¦ï¼šå…è®¸ flex å­å…ƒç´ æ”¶ç¼© */
    }

    /* å³ä¾§å±æ€§é¢æ¿ */
    .editor-sidebar-right {
        width: 320px;
        background: white;
        border-left: 1px solid var(--border-color);
        overflow-y: auto;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
    }

    /* é¡µé¢åˆ—è¡¨é¡¹ */
    .page-item {
        padding: var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        cursor: pointer;
        transition: background 0.2s ease;
    }

    .page-item:hover {
        background: var(--bg-hover);
    }

    .page-item.active {
        background: var(--primary-color);
        color: white;
    }

    .page-item-title {
        font-weight: 600;
        margin-bottom: 4px;
    }

    .page-item-info {
        font-size: 0.85rem;
        opacity: 0.8;
    }

    /* å±æ€§é¢æ¿ Tab */
    .property-tabs {
        display: flex;
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
    }

    .property-tab {
        flex: 1;
        padding: var(--spacing-sm);
        border: none;
        background: none;
        cursor: pointer;
        font-size: 0.9rem;
        color: var(--text-secondary);
        transition: all 0.2s ease;
        border-bottom: 2px solid transparent;
    }

    .property-tab.active {
        color: var(--primary-color);
        border-bottom-color: var(--primary-color);
        font-weight: 600;
    }

    .property-content {
        flex: 1;
        overflow-y: auto;
        padding: var(--spacing-md);
    }

    /* æ‰¹é‡æ“ä½œæ  */
    .batch-actions-bar {
        padding: var(--spacing-sm) var(--spacing-md);
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
    }

    .batch-actions-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--spacing-xs);
    }

    .batch-actions-title {
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .element-stats {
        font-size: 0.75rem;
        color: var(--text-secondary);
        background: white;
        padding: 2px 8px;
        border-radius: 10px;
        border: 1px solid var(--border-color);
    }

    .batch-actions-buttons {
        display: flex;
        gap: var(--spacing-xs);
        flex-wrap: wrap;
    }

    .batch-btn {
        flex: 1;
        min-width: 0;
        padding: 6px 8px;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        background: white;
        color: var(--text-color);
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .batch-btn:hover {
        border-color: var(--primary-color);
        background: var(--bg-hover);
        color: var(--primary-color);
    }

    .batch-btn-accent {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-color: transparent;
    }

    .batch-btn-accent:hover {
        opacity: 0.9;
        color: white;
        border-color: transparent;
    }

    .batch-btn-ai {
        background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        color: white;
        border-color: transparent;
        flex: 1 1 100%;
    }

    .batch-btn-ai:hover {
        opacity: 0.9;
        color: white;
        border-color: transparent;
    }

    .batch-btn-small {
        flex: 0 0 auto;
        min-width: auto;
        padding: 4px 8px;
    }

    /* å¤šé€‰æ¨¡å¼åˆ‡æ¢ */
    .select-mode-toggle {
        display: flex;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        font-size: 0.8rem;
        color: var(--text-secondary);
        user-select: none;
    }

    .select-mode-toggle input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
        accent-color: var(--primary-color);
    }

    .select-mode-toggle:hover {
        color: var(--primary-color);
    }

    /* å…ƒç´ å¤é€‰æ¡† */
    .element-checkbox {
        width: 18px;
        height: 18px;
        cursor: pointer;
        accent-color: var(--primary-color);
        flex-shrink: 0;
    }

    .element-item.multi-select-mode {
        cursor: default;
    }

    .element-item.multi-selected {
        border-color: var(--primary-color);
        background: rgba(52, 152, 219, 0.1);
    }

    /* å…ƒç´ åˆ—è¡¨ */
    .element-item {
        padding: var(--spacing-sm);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        margin-bottom: var(--spacing-sm);
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .element-item:hover {
        border-color: var(--primary-color);
        background: var(--bg-hover);
    }

    .element-item.selected {
        border-color: var(--primary-color);
        background: rgba(52, 152, 219, 0.1);
    }

    .element-number {
        display: inline-block;
        width: 24px;
        height: 24px;
        line-height: 24px;
        text-align: center;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        font-size: 0.85rem;
        font-weight: 600;
        margin-right: var(--spacing-sm);
    }

    .element-item.unnamed .element-number {
        background: var(--warning-color);
    }
</style>
{% endblock %}

{% block content %}
<!-- ä¸Šä¼ åŒºåŸŸï¼ˆåˆå§‹æ˜¾ç¤ºï¼‰ -->
<div id="uploadSection" class="template-editor-fullscreen-container">
    <div class="editor-toolbar">
        <div>
            <a href="{% url 'developer_tools_page' %}" class="btn btn-secondary">
                â† è¿”å›å¼€å‘è€…å·¥å…·
            </a>
        </div>
        <h2>ğŸ¨ PPT æ¨¡æ¿ç¼–è¾‘å™¨</h2>
        <div></div>
    </div>

    <div class="editor-main" style="align-items: center; justify-content: center;">
        <div class="card" style="max-width: 600px; width: 100%; margin: var(--spacing-xl);">
            <div class="card-header">
                <h3>ğŸ“¤ ä¸Šä¼  PPT æ¨¡æ¿</h3>
            </div>
            <div class="card-body">
                <form id="uploadTemplateForm" enctype="multipart/form-data">
                    {% csrf_token %}
                    <div class="form-group">
                        <label class="form-label">é€‰æ‹© PPT æ–‡ä»¶</label>
                        <div class="file-upload-wrapper">
                            <input type="file" id="pptFileInput" name="ppt_file" accept=".pptx" required>
                            <label for="pptFileInput" class="file-upload-label">
                                <span id="fileNameDisplay">ğŸ“ ç‚¹å‡»é€‰æ‹© PPT æ–‡ä»¶</span>
                            </label>
                        </div>
                        <p style="margin-top: var(--spacing-sm); font-size: 0.9rem; color: var(--text-secondary);">
                            æ”¯æŒ .pptx æ ¼å¼ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è½¬æ¢ä¸º PDF å¹¶ç”Ÿæˆé¢„è§ˆ
                        </p>
                    </div>

                    <div style="margin-top: var(--spacing-lg);">
                        <button type="submit" class="btn btn-primary btn-large" style="width: 100%;">
                            ğŸš€ å¼€å§‹ç¼–è¾‘
                        </button>
                    </div>
                </form>

                <div
                    style="margin-top: var(--spacing-lg); padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--border-radius);">
                    <h4 style="margin-top: 0;">ğŸ“– ä½¿ç”¨è¯´æ˜</h4>
                    <ol style="margin: 0; padding-left: 1.5rem; line-height: 1.8;">
                        <li>ä¸Šä¼  PPT æ¨¡æ¿æ–‡ä»¶ï¼ˆ.pptx æ ¼å¼ï¼‰</li>
                        <li>ç³»ç»Ÿä¼šè‡ªåŠ¨ä½¿ç”¨ LibreOffice è½¬æ¢ä¸º PDF å¹¶ç”Ÿæˆé¢„è§ˆ</li>
                        <li>ç³»ç»Ÿä¼šè‡ªåŠ¨æå–æ‰€æœ‰å¯ç¼–è¾‘å…ƒç´ å¹¶æ ‡æ³¨ç¼–å·ï¼ˆâ‘ â‘¡â‘¢...ï¼‰</li>
                        <li>ç‚¹å‡»é¢„è§ˆåŒºçš„å…ƒç´ æˆ–ç¼–å·ï¼Œåœ¨å³ä¾§é¢æ¿ä¸ºå…ƒç´ å‘½å</li>
                        <li>ä½¿ç”¨è¯­ä¹‰åŒ–åç§°ï¼Œå¦‚"æ ‡é¢˜åŒº"ã€"ä½œè€…å"ã€"ä¸»è¦å†…å®¹"ç­‰</li>
                        <li>å®Œæˆåç‚¹å‡»"ä¿å­˜ PPT"å’Œ"ç”Ÿæˆé…ç½® JSON"</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ç¼–è¾‘å™¨åŒºåŸŸï¼ˆä¸Šä¼ æˆåŠŸåæ˜¾ç¤ºï¼‰ -->
<div id="editorSection" class="template-editor-fullscreen-container" style="display: none;">
    <div class="editor-toolbar">
        <div>
            <a href="{% url 'developer_tools_page' %}" class="btn btn-secondary">
                â† è¿”å›å¼€å‘è€…å·¥å…·
            </a>
        </div>
        <h2 id="editorTitle">ğŸ¨ PPT æ¨¡æ¿ç¼–è¾‘å™¨</h2>
        <div class="toolbar-actions">
            <button id="aiAutoNameAllBtn" class="btn btn-warning" title="ä½¿ç”¨ AI é‡æ–°å‘½åæ‰€æœ‰é¡µé¢ï¼ˆè¦†ç›–ç°æœ‰å‘½åï¼‰">
                ğŸ¤– AI ä¸€é”®å‘½å
            </button>
            <button id="aiAutoFillBtn" class="btn btn-info" title="ä½¿ç”¨ AI è¡¥å…¨ç¼ºå¤±çš„é…ç½®ï¼ˆä¿ç•™ç°æœ‰å‘½åï¼‰">
                âœ¨ AI æŸ¥æ¼è¡¥ç¼º
            </button>
            <button id="saveTemplateBtn" class="btn btn-success">
                ğŸ’¾ ä¿å­˜
            </button>
            <button id="generateConfigBtn" class="btn btn-primary">
                ğŸ“„ ç”Ÿæˆé…ç½®
            </button>
            <button id="uploadNewBtn" class="btn btn-secondary">
                ğŸ“‚ ä¸Šä¼ æ–°æ¨¡æ¿
            </button>
        </div>
    </div>

    <div class="editor-main">
        <!-- å·¦ä¾§é¡µé¢åˆ—è¡¨ -->
        <div class="editor-sidebar-left">
            <div
                style="padding: var(--spacing-md); border-bottom: 1px solid var(--border-color); background: var(--bg-secondary);">
                <h4 style="margin: 0; font-size: 0.95rem;">ğŸ“‘ é¡µé¢åˆ—è¡¨</h4>
            </div>
            <!-- è¿›åº¦æ¡ -->
            <div
                style="padding: var(--spacing-sm); border-bottom: 1px solid var(--border-color); background: var(--bg-color);">
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.25rem;">
                    å·²å‘½å: <span id="namedCount">0 / 0</span> (<span id="progressPercent">0%</span>)
                </div>
                <div style="height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden;">
                    <div id="progressBar"
                        style="height: 100%; background: var(--success-color); width: 0%; transition: width 0.3s ease;">
                    </div>
                </div>
            </div>
            <div id="pageList">
                <!-- Pages will be populated here -->
            </div>
        </div>

        <!-- ä¸­é—´é¢„è§ˆåŒº -->
        <div class="editor-canvas-area">
            <div class="canvas-toolbar">
                <h4 id="currentPageTitle" style="margin: 0;">ç¬¬ 1 é¡µ</h4>
                <div style="display: flex; gap: var(--spacing-sm); align-items: center;">
                    <button id="zoomOutBtn" class="btn btn-secondary btn-small">ğŸ”-</button>
                    <span id="zoomLevel">100%</span>
                    <button id="zoomInBtn" class="btn btn-secondary btn-small">ğŸ”+</button>
                    <button id="fitToWindowBtn" class="btn btn-secondary btn-small">âš™ï¸ é€‚åº”çª—å£</button>
                </div>
            </div>
            <div class="canvas-container" id="canvasContainer">
                <!-- ä½¿ç”¨åç«¯ç”Ÿæˆçš„æ ‡æ³¨å›¾ç‰‡ï¼Œä¸éœ€è¦ Canvas äº¤äº’ -->
                <img id="previewImage" src="" alt="PPT é¢„è§ˆ" style="max-width: 100%; max-height: 100%; display: block;">
            </div>
            <div
                style="padding: var(--spacing-sm); background: white; border-top: 1px solid var(--border-color); font-size: 0.85rem; color: var(--text-secondary); text-align: center;">
                ğŸ’¡ å¿«æ·é”®: â†â†’ åˆ‡æ¢é¡µé¢ | åœ¨å³ä¾§åˆ—è¡¨ä¸­é€‰æ‹©å…ƒç´ è¿›è¡Œå‘½å
            </div>
        </div>

        <!-- å³ä¾§å±æ€§é¢æ¿ -->
        <div class="editor-sidebar-right">
            <div class="property-tabs">
                <button id="elementListTabBtn" class="property-tab active" onclick="switchPropertyTab('list')">
                    ğŸ“‹ å…ƒç´ åˆ—è¡¨
                </button>
                <button id="elementEditTabBtn" class="property-tab" onclick="switchPropertyTab('edit')">
                    âœï¸ ç¼–è¾‘å±æ€§
                </button>
            </div>

            <!-- æ‰¹é‡æ“ä½œæ  -->
            <div id="batchActionsBar" class="batch-actions-bar" style="display: none;">
                <div class="batch-actions-header">
                    <label class="select-mode-toggle">
                        <input type="checkbox" id="selectModeToggle" onchange="toggleSelectMode()">
                        <span>å¤šé€‰æ¨¡å¼</span>
                    </label>
                    <span id="elementStats" class="element-stats"></span>
                </div>
                <!-- å¤šé€‰æ¨¡å¼ä¸‹çš„æ“ä½œæŒ‰é’® -->
                <div id="batchSelectActions" class="batch-actions-buttons" style="display: none;">
                    <button class="batch-btn batch-btn-small" onclick="selectAllElements()" title="å…¨é€‰">
                        â˜‘ï¸ å…¨é€‰
                    </button>
                    <button class="batch-btn batch-btn-small" onclick="deselectAllElements()" title="å–æ¶ˆå…¨é€‰">
                        â¬œ å–æ¶ˆ
                    </button>
                    <button class="batch-btn" onclick="batchHideSelected()" title="éšè—é€‰ä¸­çš„å…ƒç´ ">
                        ğŸ™ˆ éšè—é€‰ä¸­
                    </button>
                    <button class="batch-btn" onclick="batchShowSelected()" title="æ˜¾ç¤ºé€‰ä¸­çš„å…ƒç´ ">
                        ğŸ‘ï¸ æ˜¾ç¤ºé€‰ä¸­
                    </button>
                </div>
                <!-- å¿«æ·æ“ä½œæŒ‰é’®ï¼ˆéå¤šé€‰æ¨¡å¼ï¼‰ -->
                <div id="batchQuickActions" class="batch-actions-buttons">
                    <button class="batch-btn" onclick="batchShowAll()" title="æ˜¾ç¤ºå…¨éƒ¨å…ƒç´ ">
                        ğŸ‘ï¸ å…¨éƒ¨æ˜¾ç¤º
                    </button>
                    <button class="batch-btn" onclick="batchHideAll()" title="éšè—å…¨éƒ¨å…ƒç´ ">
                        ğŸ™ˆ å…¨éƒ¨éšè—
                    </button>
                    <button class="batch-btn batch-btn-accent" onclick="batchHideUnnamed()" title="åªéšè—æœªå‘½åçš„å…ƒç´ ">
                        ğŸ¯ éšè—æœªå‘½å
                    </button>
                    <button id="aiAutoNameBtn" class="batch-btn batch-btn-ai" title="ä½¿ç”¨ AI è‡ªåŠ¨ä¸ºæœ¬é¡µå…ƒç´ å‘½å">
                        ğŸ¤– AI å‘½åæœ¬é¡µ
                    </button>
                </div>
            </div>

            <!-- å…ƒç´ åˆ—è¡¨è§†å›¾ -->
            <div id="elementListView" class="property-content">
                <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                    è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¡µé¢
                </p>
            </div>

            <!-- ç¼–è¾‘å±æ€§è§†å›¾ -->
            <div id="elementEditView" class="property-content" style="display: none;">
                <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                    è¯·ç‚¹å‡»å·¦ä¾§é¢„è§ˆåŒºçš„å…ƒç´ å¼€å§‹ç¼–è¾‘
                </p>
            </div>
        </div>
    </div>
</div>

<!-- é¡µé¢å¤‡æ³¨æ¨¡æ€æ¡† -->
<div id="pageNoteModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                                background: rgba(0,0,0,0.5); z-index: 10000;
                                justify-content: center; align-items: center;">
    <div style="background: white; border-radius: 12px; padding: 24px; width: 90%; max-width: 500px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="margin: 0; font-size: 1.1rem;">ğŸ“ ç¼–è¾‘é¡µé¢å¤‡æ³¨</h3>
            <button onclick="closePageNoteModal()" style="background: none; border: none; font-size: 1.5rem;
                            cursor: pointer; color: #999;">&times;</button>
        </div>
        <p style="color: #666; font-size: 0.9rem; margin-bottom: 12px;">
            é¡µé¢å¤‡æ³¨ç”¨äºå‘Šè¯‰ AI è¿™ä¸€é¡µçš„ç”¨é€”å’Œå†…å®¹è¦æ±‚ï¼Œå¸®åŠ©ç”Ÿæˆæ›´å‡†ç¡®çš„å†…å®¹ã€‚
        </p>
        <textarea id="pageNoteTextarea" rows="5" placeholder="ä¾‹å¦‚ï¼šè¿™æ˜¯è¯¾ç¨‹ä»‹ç»é¡µï¼Œéœ€è¦å±•ç¤ºè¯¾ç¨‹åç§°ã€è®²å¸ˆä¿¡æ¯å’Œè¯¾ç¨‹äº®ç‚¹..." style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px;
                         font-size: 0.95rem; resize: vertical; box-sizing: border-box;"></textarea>
        <div style="display: flex; justify-content: flex-end; gap: 12px; margin-top: 16px;">
            <button onclick="closePageNoteModal()" class="btn btn-secondary">å–æ¶ˆ</button>
            <button onclick="savePageNote()" class="btn btn-primary">ä¿å­˜</button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    console.log('ğŸš€ æ¨¡æ¿ç¼–è¾‘å™¨è„šæœ¬å¼€å§‹åŠ è½½...');

    // ========================================
    // Template Editor State
    // ========================================

    let templateEditorState = {
        templateId: null,
        templateName: null,
        pptPath: null,
        pages: [],
        currentPageNum: 1,
        selectedShapeId: null,  // å½“å‰é€‰ä¸­çš„å…ƒç´ 
        imageCache: new Map(),  // å›¾ç‰‡ç¼“å­˜ï¼Œé¿å…é‡å¤åŠ è½½
        embeddedMode: false,    // åµŒå…¥æ¨¡å¼æ ‡è®°
        wizardMode: false       // å‘å¯¼æ¨¡å¼æ ‡è®°ï¼ˆæ˜¾ç¤º hint/max_chars/required/noteï¼‰
    };

    // ========================================
    // Utility Functions
    // ========================================

    // Loading overlay
    function showLoading(message = 'å¤„ç†ä¸­...') {
        let overlay = document.getElementById('loadingOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'loadingOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0;
                width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex; flex-direction: column;
                justify-content: center; align-items: center;
                z-index: 9999; color: white; font-size: 1.2rem;
            `;
            overlay.innerHTML = `
                <div style="text-align: center;">
                    <div class="spinner" style="width: 50px; height: 50px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
                    <div id="loadingMessage">${message}</div>
                </div>
                <style>
                    @keyframes spin {
                        to { transform: rotate(360deg); }
                    }
                </style>
            `;
            document.body.appendChild(overlay);
        } else {
            overlay.style.display = 'flex';
            document.getElementById('loadingMessage').textContent = message;
        }
    }

    function hideLoading() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    // Toast notifications
    function showToast(message, type = 'info') {
        const colors = {
            success: '#2ecc71',
            error: '#e74c3c',
            warning: '#f39c12',
            info: '#3498db'
        };

        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed; top: 20px; right: 20px;
            background: ${colors[type]}; color: white;
            padding: 1rem 1.5rem; border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000; font-size: 1rem;
            animation: slideIn 0.3s ease;
        `;
        toast.innerHTML = `
            <style>
                @keyframes slideIn {
                    from { transform: translateX(400px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            </style>
            ${message}
        `;
        document.body.appendChild(toast);

        setTimeout(() => {
            toast.style.animation = 'slideIn 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
        }, 3000);
    }

    function showSuccess(message) { showToast(message, 'success'); }
    function showError(message) { showToast(message, 'error'); }
    function showWarning(message) { showToast(message, 'warning'); }
    function showInfo(message) { showToast(message, 'info'); }

    // Get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Download JSON
    function downloadJSON(data, filename) {
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    // ========================================
    // å¤šé€‰æ¨¡å¼åŠŸèƒ½
    // ========================================

    // åˆ‡æ¢å¤šé€‰æ¨¡å¼
    function toggleSelectMode() {
        const checkbox = document.getElementById('selectModeToggle');
        templateEditorState.multiSelectMode = checkbox.checked;
        templateEditorState.selectedShapeIds = [];  // æ¸…ç©ºé€‰ä¸­åˆ—è¡¨

        // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
        const selectActions = document.getElementById('batchSelectActions');
        const quickActions = document.getElementById('batchQuickActions');

        if (templateEditorState.multiSelectMode) {
            selectActions.style.display = 'flex';
            quickActions.style.display = 'none';
        } else {
            selectActions.style.display = 'none';
            quickActions.style.display = 'flex';
        }

        renderElementList();
        updateElementStats();
    }

    // åˆ‡æ¢å•ä¸ªå…ƒç´ çš„é€‰ä¸­çŠ¶æ€
    function toggleElementSelection(shapeId) {
        if (!templateEditorState.selectedShapeIds) {
            templateEditorState.selectedShapeIds = [];
        }

        const index = templateEditorState.selectedShapeIds.indexOf(shapeId);
        if (index > -1) {
            templateEditorState.selectedShapeIds.splice(index, 1);
        } else {
            templateEditorState.selectedShapeIds.push(shapeId);
        }

        renderElementList();
        updateElementStats();
    }

    // å…¨é€‰å…ƒç´ 
    function selectAllElements() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        templateEditorState.selectedShapeIds = page.shapes.map(s => s.shape_id);
        renderElementList();
        updateElementStats();
    }

    // å–æ¶ˆå…¨é€‰
    function deselectAllElements() {
        templateEditorState.selectedShapeIds = [];
        renderElementList();
        updateElementStats();
    }

    // éšè—é€‰ä¸­çš„å…ƒç´ 
    async function batchHideSelected() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const selectedIds = templateEditorState.selectedShapeIds || [];
        if (selectedIds.length === 0) {
            showWarning('è¯·å…ˆé€‰æ‹©è¦éšè—çš„å…ƒç´ ');
            return;
        }

        // éšè—é€‰ä¸­çš„å…ƒç´ 
        page.shapes.forEach(s => {
            if (selectedIds.includes(s.shape_id)) {
                s.is_hidden = true;
            }
        });

        await refreshPreviewAfterBatch(page);
        templateEditorState.selectedShapeIds = [];  // æ¸…ç©ºé€‰ä¸­
        showSuccess(`å·²éšè— ${selectedIds.length} ä¸ªå…ƒç´ `);
    }

    // æ˜¾ç¤ºé€‰ä¸­çš„å…ƒç´ 
    async function batchShowSelected() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const selectedIds = templateEditorState.selectedShapeIds || [];
        if (selectedIds.length === 0) {
            showWarning('è¯·å…ˆé€‰æ‹©è¦æ˜¾ç¤ºçš„å…ƒç´ ');
            return;
        }

        // æ˜¾ç¤ºé€‰ä¸­çš„å…ƒç´ 
        page.shapes.forEach(s => {
            if (selectedIds.includes(s.shape_id)) {
                s.is_hidden = false;
            }
        });

        await refreshPreviewAfterBatch(page);
        templateEditorState.selectedShapeIds = [];  // æ¸…ç©ºé€‰ä¸­
        showSuccess(`å·²æ˜¾ç¤º ${selectedIds.length} ä¸ªå…ƒç´ `);
    }

    // ========================================
    // ç¼–è¾‘ä¼šè¯ç®¡ç†
    // ========================================

    // ä¿å­˜ç¼–è¾‘ä¼šè¯åˆ°æœåŠ¡å™¨
    async function saveEditSession() {
        if (!templateEditorState.templateId) return;

        // è®¡ç®—è¿›åº¦æ•°æ®
        let totalCount = 0;
        let namedCount = 0;
        templateEditorState.pages.forEach(page => {
            const visibleShapes = page.shapes.filter(s => !s.is_hidden);
            totalCount += visibleShapes.length;
            namedCount += visibleShapes.filter(s => s.is_named).length;
        });

        // è·å–ç¬¬ä¸€é¡µçš„ç¼©ç•¥å›¾ä½œä¸ºé¢„è§ˆ
        const firstPage = templateEditorState.pages[0];
        const thumbnailUrl = firstPage ? firstPage.image_url : null;

        // ä¿å­˜æ¯ä¸ªå…ƒç´ çš„éšè—çŠ¶æ€ï¼ˆç”¨äºæ¢å¤ï¼‰
        const hiddenShapes = {};
        // ä¿å­˜æ¯ä¸ªé¡µé¢çš„åç§°ï¼ˆç”¨äºæ¢å¤ï¼‰
        const pageTypes = {};
        // ä¿å­˜æ¯ä¸ªé¡µé¢çš„å¤‡æ³¨ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
        const pageNotes = {};
        // ä¿å­˜å…ƒç´ çš„é…ç½®å±æ€§ï¼ˆå‘å¯¼æ¨¡å¼ï¼šhint/max_chars/requiredï¼‰
        const shapeConfigs = {};

        templateEditorState.pages.forEach(page => {
            const pageHiddenIds = page.shapes
                .filter(s => s.is_hidden)
                .map(s => s.shape_id);
            if (pageHiddenIds.length > 0) {
                hiddenShapes[page.page_num] = pageHiddenIds;
            }
            // ä¿å­˜é¡µé¢åç§°
            if (page.page_type) {
                pageTypes[page.page_num] = page.page_type;
            }
            // ä¿å­˜é¡µé¢å¤‡æ³¨
            if (page.note) {
                pageNotes[page.page_num] = page.note;
            }
            // ä¿å­˜å…ƒç´ é…ç½®ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
            if (templateEditorState.wizardMode) {
                const pageShapeConfigs = {};
                page.shapes.forEach(shape => {
                    if (shape.hint || shape.max_chars || shape.required) {
                        pageShapeConfigs[shape.shape_id] = {
                            hint: shape.hint || '',
                            max_chars: shape.max_chars || null,
                            required: shape.required || false
                        };
                    }
                });
                if (Object.keys(pageShapeConfigs).length > 0) {
                    shapeConfigs[page.page_num] = pageShapeConfigs;
                }
            }
        });

        try {
            await fetch('/developer-tools/edit-sessions/save/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    session_id: templateEditorState.templateId,
                    editor_type: 'ppt',
                    template_name: templateEditorState.templateName || 'æœªå‘½åæ¨¡æ¿',
                    progress_data: {
                        total_count: totalCount,
                        named_count: namedCount,
                        page_count: templateEditorState.pages.length,
                        hidden_shapes: hiddenShapes,
                        page_types: pageTypes,
                        page_notes: pageNotes,      // é¡µé¢å¤‡æ³¨ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
                        shape_configs: shapeConfigs, // å…ƒç´ é…ç½®ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
                        from_wizard: templateEditorState.embeddedMode,
                        wizard_mode: templateEditorState.wizardMode
                    },
                    thumbnail_url: thumbnailUrl
                })
            });
        } catch (e) {
            console.error('ä¿å­˜ç¼–è¾‘ä¼šè¯å¤±è´¥:', e);
        }
    }

    // æ¢å¤ç¼–è¾‘ä¼šè¯
    async function restoreEditSession(sessionId) {
        try {
            showLoading('æ­£åœ¨æ¢å¤ç¼–è¾‘ä¼šè¯...');

            // æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨ï¼Œå¹¶è·å–ä¿å­˜çš„çŠ¶æ€
            let hiddenShapes = {};
            let pageTypes = {};
            let pageNotes = {};
            let shapeConfigs = {};
            let savedWizardMode = false;
            try {
                const checkResponse = await fetch(`/developer-tools/edit-sessions/${sessionId}/`);
                const checkData = await checkResponse.json();
                if (checkResponse.ok && checkData.exists) {
                    const progressData = checkData.session?.progress_data || {};
                    hiddenShapes = progressData.hidden_shapes || {};
                    pageTypes = progressData.page_types || {};
                    pageNotes = progressData.page_notes || {};
                    shapeConfigs = progressData.shape_configs || {};
                    savedWizardMode = progressData.wizard_mode || false;
                }
                // å¦‚æœ session ä¸å­˜åœ¨ï¼Œç»§ç»­å°è¯•åŠ è½½æ•°æ®ï¼ˆå¯èƒ½æ˜¯ä»å‘å¯¼ç›´æ¥ä¼ å…¥çš„ template_idï¼‰
            } catch (e) {
                console.log('[restoreEditSession] æ— æ³•è·å– session ä¿¡æ¯ï¼Œç»§ç»­å°è¯•åŠ è½½æ•°æ®');
            }

            // å°è¯•æ¢å¤ä¼šè¯æ•°æ®
            const response = await fetch(`/developer-tools/restore-session/${sessionId}/`);
            const data = await response.json();

            if (response.ok) {
                templateEditorState.templateId = data.template_id;
                templateEditorState.templateName = data.template_name;
                templateEditorState.pptPath = data.ppt_path;
                templateEditorState.slideWidth = data.slide_width || 12192000;
                templateEditorState.slideHeight = data.slide_height || 6858000;
                templateEditorState.pages = data.pages;
                templateEditorState.currentPageNum = 1;
                templateEditorState.imageCache.clear();

                // æ¢å¤éšè—çŠ¶æ€
                if (Object.keys(hiddenShapes).length > 0) {
                    templateEditorState.pages.forEach(page => {
                        const pageHiddenIds = hiddenShapes[page.page_num] || [];
                        page.shapes.forEach(shape => {
                            if (pageHiddenIds.includes(shape.shape_id)) {
                                shape.is_hidden = true;
                            }
                        });
                    });
                    console.log('[restoreEditSession] å·²æ¢å¤éšè—çŠ¶æ€:', hiddenShapes);
                }

                // æ¢å¤é¡µé¢åç§°
                if (Object.keys(pageTypes).length > 0) {
                    templateEditorState.pages.forEach(page => {
                        const savedPageType = pageTypes[page.page_num];
                        if (savedPageType) {
                            page.page_type = savedPageType;
                        }
                    });
                    console.log('[restoreEditSession] å·²æ¢å¤é¡µé¢åç§°:', pageTypes);
                }

                // æ¢å¤é¡µé¢å¤‡æ³¨ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
                if (Object.keys(pageNotes).length > 0) {
                    templateEditorState.pages.forEach(page => {
                        const savedNote = pageNotes[page.page_num];
                        if (savedNote) {
                            page.note = savedNote;
                        }
                    });
                    console.log('[restoreEditSession] å·²æ¢å¤é¡µé¢å¤‡æ³¨:', pageNotes);
                }

                // æ¢å¤å…ƒç´ é…ç½®ï¼ˆå‘å¯¼æ¨¡å¼ï¼šhint/max_chars/requiredï¼‰
                if (Object.keys(shapeConfigs).length > 0) {
                    templateEditorState.pages.forEach(page => {
                        const pageShapeConfigs = shapeConfigs[page.page_num] || {};
                        page.shapes.forEach(shape => {
                            const savedConfig = pageShapeConfigs[shape.shape_id];
                            if (savedConfig) {
                                shape.hint = savedConfig.hint || '';
                                shape.max_chars = savedConfig.max_chars || null;
                                shape.required = savedConfig.required || false;
                            }
                        });
                    });
                    console.log('[restoreEditSession] å·²æ¢å¤å…ƒç´ é…ç½®:', shapeConfigs);
                }

                // æ¢å¤å‘å¯¼æ¨¡å¼ï¼ˆå¦‚æœä¹‹å‰ä¿å­˜æ—¶æ˜¯å‘å¯¼æ¨¡å¼ï¼Œä¸”å½“å‰ URL ä¹Ÿæ˜¯å‘å¯¼æ¨¡å¼ï¼‰
                if (savedWizardMode && templateEditorState.wizardMode) {
                    console.log('[restoreEditSession] å‘å¯¼æ¨¡å¼å·²æ¢å¤');
                }

                // æ˜¾ç¤ºç¼–è¾‘å™¨
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('editorSection').style.display = 'flex';

                renderPageList();
                loadPage(1);

                hideLoading();
                showSuccess(`âœ… å·²æ¢å¤ç¼–è¾‘ä¼šè¯ï¼š${data.template_name}`);
                return true;
            } else {
                hideLoading();
                showError('æ¢å¤ä¼šè¯å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                return false;
            }
        } catch (error) {
            hideLoading();
            showError('æ¢å¤ä¼šè¯å¤±è´¥: ' + error.message);
            return false;
        }
    }

    // æ£€æŸ¥ URL ä¸­æ˜¯å¦æœ‰è¦æ¢å¤çš„ä¼šè¯
    function checkRestoreSession() {
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('session');
        const embedded = urlParams.get('embedded') === '1';

        // åµŒå…¥æ¨¡å¼å¤„ç†
        if (embedded) {
            templateEditorState.embeddedMode = true;
            document.body.classList.add('embedded-mode');
            // ç›´æ¥æ˜¾ç¤ºç¼–è¾‘å™¨åŒºåŸŸï¼Œéšè—ä¸Šä¼ åŒºåŸŸ
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('editorSection').style.display = 'flex';
        }

        // å‘å¯¼æ¨¡å¼å¤„ç†ï¼ˆé€šè¿‡ URL å‚æ•° wizard=1ï¼‰
        const wizardParam = urlParams.get('wizard');
        if (wizardParam === '1') {
            templateEditorState.wizardMode = true;
            document.body.classList.add('wizard-mode');
        }

        if (sessionId) {
            restoreEditSession(sessionId);
        }
    }

    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦éœ€è¦æ¢å¤ä¼šè¯
    checkRestoreSession();

    // ========================================
    // Template Upload
    // ========================================

    const uploadForm = document.getElementById('uploadTemplateForm');
    console.log('ğŸ“‹ è¡¨å•å…ƒç´ :', uploadForm);

    if (uploadForm) {
        uploadForm.addEventListener('submit', async function (e) {
            console.log('ğŸ“¤ è¡¨å•æäº¤äº‹ä»¶è§¦å‘');
            e.preventDefault();

            const formData = new FormData(this);
            const pptFile = formData.get('ppt_file');
            console.log('ğŸ“„ æ–‡ä»¶:', pptFile ? pptFile.name : 'æœªé€‰æ‹©');

            if (!pptFile || pptFile.size === 0) {
                showWarning('è¯·é€‰æ‹© PPT æ–‡ä»¶');
                return;
            }

            // ç¦ç”¨æäº¤æŒ‰é’®
            const submitBtn = this.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'â³ å¤„ç†ä¸­...';

            try {
                console.log('ğŸ”„ å¼€å§‹ä¸Šä¼ ...');
                showLoading('ğŸ“¤ æ­£åœ¨ä¸Šä¼  PPT æ–‡ä»¶...');

                const response = await fetch('/developer-tools/parse-ppt/', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: formData
                });

                console.log('ğŸ“¡ å“åº”çŠ¶æ€:', response.status);
                document.getElementById('loadingMessage').textContent = 'ğŸ”„ æ­£åœ¨ä½¿ç”¨ LibreOffice è½¬æ¢ PDF...';

                const data = await response.json();
                console.log('ğŸ“¦ å“åº”æ•°æ®:', data);

                if (response.ok) {
                    document.getElementById('loadingMessage').textContent = 'ğŸ–¼ï¸ æ­£åœ¨ç”Ÿæˆé¢„è§ˆå›¾ç‰‡...';

                    templateEditorState.templateId = data.template_id;
                    templateEditorState.templateName = pptFile.name;  // ä¿å­˜æ–‡ä»¶å
                    templateEditorState.pptPath = data.ppt_path;
                    // ä¿å­˜å¹»ç¯ç‰‡å°ºå¯¸ï¼ˆç”¨äºæ­£ç¡®è®¡ç®—å…ƒç´ ä½ç½®ï¼‰
                    templateEditorState.slideWidth = data.slide_width || 12192000;
                    templateEditorState.slideHeight = data.slide_height || 6858000;
                    templateEditorState.pages = data.pages;
                    templateEditorState.currentPageNum = 1;
                    templateEditorState.imageCache.clear();

                    // æ˜¾ç¤ºç¼–è¾‘å™¨
                    document.getElementById('uploadSection').style.display = 'none';
                    document.getElementById('editorSection').style.display = 'flex';

                    // æ¸²æŸ“é¡µé¢åˆ—è¡¨
                    renderPageList();

                    // åŠ è½½ç¬¬ä¸€é¡µ
                    loadPage(1);

                    // ä¿å­˜ç¼–è¾‘ä¼šè¯
                    saveEditSession();

                    hideLoading();
                    showSuccess(`âœ… æ¨¡æ¿è§£ææˆåŠŸï¼å…± ${data.pages.length} é¡µï¼Œä½¿ç”¨æ‡’åŠ è½½æå‡é€Ÿåº¦`);
                } else {
                    hideLoading();
                    showError('âŒ è§£æå¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                hideLoading();
                showError('âŒ ä¸Šä¼ å¤±è´¥: ' + error.message);
                console.error('Upload error:', error);
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        });
        console.log('âœ… è¡¨å•äº‹ä»¶ç›‘å¬å™¨å·²ç»‘å®š');
    } else {
        console.error('âŒ æœªæ‰¾åˆ°è¡¨å•å…ƒç´  #uploadTemplateForm');
    }

    // ========================================
    // File Input Display
    // ========================================

    const fileInput = document.getElementById('pptFileInput');
    const fileNameDisplay = document.getElementById('fileNameDisplay');

    if (fileInput && fileNameDisplay) {
        fileInput.addEventListener('change', function () {
            if (this.files && this.files[0]) {
                fileNameDisplay.textContent = 'ğŸ“„ ' + this.files[0].name;
                fileNameDisplay.style.color = 'var(--success-color)';
            } else {
                fileNameDisplay.textContent = 'ğŸ“ ç‚¹å‡»é€‰æ‹© PPT æ–‡ä»¶';
                fileNameDisplay.style.color = '';
            }
        });
    }

    // ========================================
    // Page List Rendering
    // ========================================

    function renderPageList() {
        const pageList = document.getElementById('pageList');
        pageList.innerHTML = '';

        templateEditorState.pages.forEach((page, index) => {
            const totalShapes = page.shapes.filter(s => !s.is_hidden).length;
            const namedShapes = page.shapes.filter(s => !s.is_hidden && s.is_named).length;
            const percent = totalShapes > 0 ? Math.round(namedShapes / totalShapes * 100) : 0;

            // é¡µé¢åç§°ï¼šä¼˜å…ˆä½¿ç”¨ page_typeï¼Œå¦åˆ™æ˜¾ç¤º"ç¬¬Xé¡µ"
            const pageName = page.page_type || `ç¬¬${page.page_num}é¡µ`;

            const pageItem = document.createElement('div');
            pageItem.className = 'page-item' + (page.page_num === templateEditorState.currentPageNum ? ' active' : '');
            pageItem.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <span style="font-weight: bold;" title="${pageName}">${pageName.length > 6 ? pageName.substring(0, 6) + '...' : pageName}</span>
                    <span style="font-size: 0.85rem; color: ${percent === 100 ? 'var(--success-color)' : 'var(--text-secondary)'};">
                        ${percent}%
                    </span>
                </div>
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                    ${namedShapes} / ${totalShapes} å·²å‘½å
                </div>
                <div style="height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden;">
                    <div style="height: 100%; background: var(--success-color); width: ${percent}%; transition: width 0.3s ease;"></div>
                </div>
            `;
            pageItem.onclick = () => loadPage(page.page_num);
            pageList.appendChild(pageItem);
        });
    }

    // ========================================
    // Page Loading (Lazy Loading + Caching)
    // ========================================

    function loadPage(pageNum) {
        const page = templateEditorState.pages.find(p => p.page_num === pageNum);
        if (!page) return;

        templateEditorState.currentPageNum = pageNum;

        // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
        templateEditorState.selectedShapeId = null;

        // åˆ‡æ¢åˆ°å…ƒç´ åˆ—è¡¨è§†å›¾ï¼ˆè€Œä¸æ˜¯ç¼–è¾‘è§†å›¾ï¼‰
        switchPropertyTab('list');

        // æ¸…ç©ºç¼–è¾‘é¢æ¿
        document.getElementById('elementEditView').innerHTML = `
            <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                è¯·ä»å·¦ä¾§åˆ—è¡¨é€‰æ‹©ä¸€ä¸ªå…ƒç´ è¿›è¡Œç¼–è¾‘
            </p>
        `;

        // æ›´æ–°é¡µé¢æ ‡é¢˜ï¼ˆæ˜¾ç¤ºé¡µé¢åç§°ï¼Œå¯ç¼–è¾‘ï¼‰
        const pageName = page.page_type || `ç¬¬${pageNum}é¡µ`;
        const isWizardMode = templateEditorState.wizardMode;

        // å‘å¯¼æ¨¡å¼ä¸‹æ˜¾ç¤ºé¡µé¢å¤‡æ³¨æŒ‰é’®
        const noteBtn = isWizardMode ? `
            <button onclick="openPageNoteModal(${pageNum})"
                    style="margin-left: 8px; padding: 4px 10px; font-size: 0.8rem;
                           background: ${page.note ? 'var(--primary-color)' : 'var(--bg-secondary)'};
                           color: ${page.note ? 'white' : 'var(--text-secondary)'};
                           border: 1px solid ${page.note ? 'var(--primary-color)' : 'var(--border-color)'};
                           border-radius: var(--radius-sm); cursor: pointer;
                           transition: all 0.2s;"
                    title="${page.note ? 'ç¼–è¾‘é¡µé¢å¤‡æ³¨' : 'æ·»åŠ é¡µé¢å¤‡æ³¨'}">
                ğŸ“ ${page.note ? 'å¤‡æ³¨' : 'æ·»åŠ å¤‡æ³¨'}
            </button>
        ` : '';

        document.getElementById('currentPageTitle').innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="color: var(--text-secondary); font-size: 0.9rem;">ç¬¬${pageNum}é¡µ Â· </span>
                <input type="text" id="pageNameInput" value="${pageName}"
                       style="border: none; background: transparent; font-size: inherit; font-weight: inherit;
                              color: inherit; padding: 2px 4px; border-radius: 4px; max-width: 150px;
                              transition: background 0.2s;"
                       onmouseover="this.style.background='var(--bg-secondary)'"
                       onmouseout="if(document.activeElement!==this)this.style.background='transparent'"
                       onfocus="this.style.background='var(--bg-secondary)';this.select()"
                       onblur="this.style.background='transparent';updatePageName(${pageNum}, this.value)"
                       onkeydown="if(event.key==='Enter'){this.blur()}"
                       title="ç‚¹å‡»ç¼–è¾‘é¡µé¢åç§°">
                ${noteBtn}
            </div>
        `;

        // æ›´æ–°é¡µé¢åˆ—è¡¨é«˜äº®
        document.querySelectorAll('#pageList .page-item').forEach((item, index) => {
            item.classList.toggle('active', index + 1 === pageNum);
        });

        // æ£€æŸ¥ç¼“å­˜
        if (templateEditorState.imageCache.has(page.image_url)) {
            renderCanvas(page);
            return;
        }

        // æ˜¾ç¤ºåŠ è½½æç¤º
        showLoading(`ğŸ–¼ï¸ æ­£åœ¨åŠ è½½ç¬¬ ${pageNum} é¡µé¢„è§ˆå›¾ç‰‡...`);

        // æ‡’åŠ è½½å›¾ç‰‡
        const img = new Image();
        img.onload = () => {
            templateEditorState.imageCache.set(page.image_url, img);
            renderCanvas(page);
            hideLoading();
        };

        img.onerror = () => {
            hideLoading();
            showError(`åŠ è½½ç¬¬ ${pageNum} é¡µå›¾ç‰‡å¤±è´¥`);
        };

        img.src = page.image_url;
    }

    // ========================================
    // å›¾ç‰‡é¢„è§ˆæ¸²æŸ“
    // ========================================

    function renderCanvas(page) {
        // ç®€å•åœ°è®¾ç½®å›¾ç‰‡ URLï¼ˆåç«¯å·²ç”Ÿæˆå¸¦æ ‡æ³¨çš„å›¾ç‰‡ï¼‰
        const previewImage = document.getElementById('previewImage');
        previewImage.src = page.image_url;

        // æ¸²æŸ“å…ƒç´ åˆ—è¡¨
        renderElementList();

        // æ›´æ–°è¿›åº¦
        updateProgress();

        // é¢„åŠ è½½ä¸‹ä¸€é¡µ
        preloadNextPage(page.page_num);
    }

    // é¢„åŠ è½½ä¸‹ä¸€é¡µå›¾ç‰‡
    function preloadNextPage(currentPageNum) {
        const nextPage = templateEditorState.pages.find(p => p.page_num === currentPageNum + 1);
        if (!nextPage) return;

        if (templateEditorState.imageCache.has(nextPage.image_url)) return;

        const img = new Image();
        img.onload = () => {
            templateEditorState.imageCache.set(nextPage.image_url, img);
            console.log(`âœ… é¢„åŠ è½½ç¬¬ ${nextPage.page_num} é¡µå®Œæˆ`);
        };
        img.onerror = () => {
            console.warn(`âš ï¸ é¢„åŠ è½½ç¬¬ ${nextPage.page_num} é¡µå¤±è´¥`);
        };
        img.src = nextPage.image_url;
    }

    // ========================================
    // Property Panel
    // ========================================

    // Switch property tabs
    function switchPropertyTab(tab) {
        const tabs = document.querySelectorAll('.property-tab');
        const listView = document.getElementById('elementListView');
        const editView = document.getElementById('elementEditView');
        const batchActionsBar = document.getElementById('batchActionsBar');

        if (tab === 'list') {
            tabs[0].classList.add('active');
            tabs[1].classList.remove('active');
            listView.style.display = 'block';
            editView.style.display = 'none';
            // æ˜¾ç¤ºæ‰¹é‡æ“ä½œæ ï¼ˆå¦‚æœå½“å‰é¡µé¢æœ‰å…ƒç´ ï¼‰
            if (batchActionsBar) {
                const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
                if (page && page.shapes.length > 0) {
                    batchActionsBar.style.display = 'block';
                }
            }
        } else {
            tabs[0].classList.remove('active');
            tabs[1].classList.add('active');
            listView.style.display = 'none';
            editView.style.display = 'block';
            // éšè—æ‰¹é‡æ“ä½œæ ï¼ˆç¼–è¾‘å•ä¸ªå…ƒç´ æ—¶ä¸éœ€è¦ï¼‰
            if (batchActionsBar) {
                batchActionsBar.style.display = 'none';
            }
        }
    }

    // Render element list
    function renderElementList() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const listView = document.getElementById('elementListView');
        const batchActionsBar = document.getElementById('batchActionsBar');

        if (page.shapes.length === 0) {
            listView.innerHTML = `
                <p style="color: var(--text-secondary); text-align: center; padding: var(--spacing-xl);">
                    è¯¥é¡µé¢æ²¡æœ‰å¯ç¼–è¾‘çš„å…ƒç´ 
                </p>
            `;
            if (batchActionsBar) batchActionsBar.style.display = 'none';
            return;
        }

        // æ£€æŸ¥å½“å‰æ˜¯å¦åœ¨å…ƒç´ åˆ—è¡¨æ ‡ç­¾é¡µï¼ˆåªåœ¨åˆ—è¡¨è§†å›¾æ—¶æ˜¾ç¤ºæ‰¹é‡æ“ä½œæ ï¼‰
        const isListTabActive = document.getElementById('elementListTabBtn')?.classList.contains('active');
        if (batchActionsBar && isListTabActive) {
            batchActionsBar.style.display = 'block';
            updateElementStats();
        }

        const isMultiSelectMode = templateEditorState.multiSelectMode || false;
        let html = '';
        let visibleIndex = 0;  // ç”¨äºæ˜¾ç¤ºå¯è§å…ƒç´ çš„ç¼–å·

        page.shapes.forEach((shape) => {
            const isHidden = shape.is_hidden;
            const isNamed = shape.is_named;
            const isSelected = templateEditorState.selectedShapeId === shape.shape_id;
            const isMultiSelected = templateEditorState.selectedShapeIds?.includes(shape.shape_id) || false;

            // åªç»™å¯è§å…ƒç´ åˆ†é…ç¼–å·
            if (!isHidden) {
                visibleIndex++;
            }

            // æ˜¾ç¤ºæ–‡æœ¬é¢„è§ˆï¼ˆæˆªæ–­ï¼‰
            const textPreview = shape.text_sample
                ? (shape.text_sample.length > 30 ? shape.text_sample.substring(0, 30) + '...' : shape.text_sample)
                : '';

            // éšè—å…ƒç´ æ˜¾ç¤ºä¸ºç°è‰²æ ·å¼
            const hiddenStyle = isHidden ? 'opacity: 0.5; background: #f5f5f5;' : '';
            const nameStyle = isHidden ? 'color: #999; text-decoration: line-through;' : (isNamed ? '' : 'color: var(--warning-color);');

            // å¤šé€‰æ¨¡å¼ä¸‹çš„ç±»åå’Œç‚¹å‡»äº‹ä»¶
            const multiSelectClass = isMultiSelectMode ? 'multi-select-mode' : '';
            const multiSelectedClass = isMultiSelected ? 'multi-selected' : '';
            const clickHandler = isMultiSelectMode
                ? `toggleElementSelection(${shape.shape_id})`
                : `selectElement(${shape.shape_id})`;

            html += `
                <div class="element-item ${isNamed ? '' : 'unnamed'} ${isSelected && !isMultiSelectMode ? 'selected' : ''} ${isHidden ? 'hidden-element' : ''} ${multiSelectClass} ${multiSelectedClass}"
                     style="${hiddenStyle}"
                     onclick="${clickHandler}">
                    <div style="display: flex; align-items: center; gap: var(--spacing-sm);">
                        ${isMultiSelectMode ? `
                            <input type="checkbox" class="element-checkbox"
                                   ${isMultiSelected ? 'checked' : ''}
                                   onclick="event.stopPropagation(); toggleElementSelection(${shape.shape_id})">
                        ` : ''}
                        <span class="element-number" style="${isHidden ? 'background: #ccc; color: #999;' : ''}">
                            ${isHidden ? 'â€”' : visibleIndex}
                        </span>
                        <div style="flex: 1; min-width: 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="font-weight: 600; ${nameStyle}">
                                    ${shape.name || 'æœªå‘½å'}
                                </span>
                                <span style="font-size: 0.75rem; padding: 0.125rem 0.5rem; background: ${isHidden ? '#eee' : 'var(--bg-color)'}; border-radius: 12px; ${isHidden ? 'color: #999;' : ''}">
                                    ${isHidden ? 'ğŸ™ˆ å·²éšè—' : (shape.type === 'text' ? 'ğŸ“ æ–‡æœ¬' : 'ğŸ–¼ï¸ å›¾ç‰‡')}
                                </span>
                            </div>
                            ${textPreview ? `<div style="font-size: 0.8rem; color: ${isHidden ? '#bbb' : 'var(--text-secondary)'}; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${textPreview}</div>` : ''}
                        </div>
                    </div>
                </div>
            `;
        });

        listView.innerHTML = html;
    }

    // Select element from list
    function selectElement(shapeId) {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const shape = page.shapes.find(s => s.shape_id === shapeId);

        if (shape) {
            templateEditorState.selectedShapeId = shapeId;
            renderElementList();
            switchPropertyTab('edit');
            renderPropertyPanel(shape);
        }
    }

    // Render property panel
    function renderPropertyPanel(shape) {
        const panel = document.getElementById('elementEditView');
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);

        const shapeIndex = page.shapes.findIndex(s => s.shape_id === shape.shape_id) + 1;
        const isWizardMode = templateEditorState.wizardMode;

        // å‘å¯¼æ¨¡å¼ï¼šæ˜¾ç¤ºé¡µé¢å¤‡æ³¨å’Œå…ƒç´ é…ç½®å­—æ®µ
        // æ™®é€šæ¨¡å¼ï¼šåªæ˜¾ç¤ºå…ƒç´ åç§°å’Œéšè—æŒ‰é’®
        const wizardFields = isWizardMode ? `
                <div class="form-group">
                    <label class="form-label">å†…å®¹æç¤º (hint)</label>
                    <textarea id="shapeHintInput" class="text-input" rows="2"
                              placeholder="å‘Šè¯‰ AI è¿™ä¸ªä½ç½®åº”è¯¥å¡«ä»€ä¹ˆå†…å®¹"
                              style="resize: vertical;">${shape.hint || ''}</textarea>
                    <small class="form-help">ç»™ AI çš„æç¤ºï¼Œæè¿°æ­¤å¤„åº”å¡«å†™çš„å†…å®¹</small>
                </div>

                <div class="form-group">
                    <label class="form-label">æœ€å¤§å­—æ•°</label>
                    <input type="number" id="shapeMaxCharsInput" class="text-input"
                           value="${shape.max_chars || ''}"
                           placeholder="å¦‚ï¼š50" min="1" max="9999">
                    <small class="form-help">é™åˆ¶ AI ç”Ÿæˆå†…å®¹çš„å­—æ•°ä¸Šé™</small>
                </div>

                <div class="form-group">
                    <label class="checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="shapeRequiredInput" ${shape.required ? 'checked' : ''}>
                        <span>å¿…å¡«å­—æ®µ</span>
                    </label>
                    <small class="form-help">å‹¾é€‰åï¼ŒAI å¿…é¡»ä¸ºæ­¤å­—æ®µç”Ÿæˆå†…å®¹</small>
                </div>
        ` : '';

        panel.innerHTML = `
            <div style="margin-bottom: var(--spacing-lg);">
                <h4 style="margin-bottom: var(--spacing-md);">
                    ${shape.type === 'text' ? 'ğŸ“' : 'ğŸ–¼ï¸'} å…ƒç´  #${shapeIndex}
                </h4>

                <div class="form-group">
                    <label class="form-label required">å…ƒç´ åç§°</label>
                    <input type="text" id="shapeNameInput" class="text-input"
                           value="${shape.name || ''}"
                           placeholder="ä¾‹å¦‚ï¼šæ ‡é¢˜åŒºã€ä½œè€…åã€ä¸»è¦å†…å®¹">
                    <small class="form-help">ä½¿ç”¨è¯­ä¹‰åŒ–åç§°ï¼Œæ–¹ä¾¿åç»­é…ç½®</small>
                </div>

                ${wizardFields}

                <div class="form-actions">
                    <button class="btn btn-primary btn-block" onclick="saveShapeProperties(${shape.shape_id})">
                        ğŸ’¾ ä¿å­˜${isWizardMode ? 'é…ç½®' : 'åç§°'}
                    </button>
                    <button class="btn btn-${shape.is_hidden ? 'success' : 'secondary'} btn-block"
                            onclick="toggleShapeVisibility(${shape.shape_id})">
                        ${shape.is_hidden ? 'ğŸ‘ï¸ æ˜¾ç¤ºå…ƒç´ ' : 'ğŸ™ˆ éšè—å…ƒç´ '}
                    </button>
                </div>
            </div>
        `;
    }

    // ========================================
    // Element Actions
    // ========================================

    // Save shape properties (name, and in wizard mode: hint, max_chars, required)
    async function saveShapeProperties(shapeId) {
        const newName = document.getElementById('shapeNameInput').value.trim();

        if (!newName) {
            showWarning('è¯·è¾“å…¥å…ƒç´ åç§°');
            return;
        }

        // æ‰¾åˆ°å¯¹åº”çš„ shape
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const shape = page.shapes.find(s => s.shape_id === shapeId);

        if (!shape) {
            showError('æ‰¾ä¸åˆ°å…ƒç´ ');
            return;
        }

        // æ”¶é›†å‘å¯¼æ¨¡å¼ä¸‹çš„é¢å¤–å±æ€§
        const isWizardMode = templateEditorState.wizardMode;
        let hint = '';
        let maxChars = null;
        let required = false;

        if (isWizardMode) {
            const hintInput = document.getElementById('shapeHintInput');
            const maxCharsInput = document.getElementById('shapeMaxCharsInput');
            const requiredInput = document.getElementById('shapeRequiredInput');

            hint = hintInput ? hintInput.value.trim() : '';
            maxChars = maxCharsInput && maxCharsInput.value ? parseInt(maxCharsInput.value) : null;
            required = requiredInput ? requiredInput.checked : false;
        }

        try {
            const response = await fetch('/developer-tools/update-shape-name/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shape_id: shape.shape_id,
                    new_name: newName
                })
            });

            const data = await response.json();

            if (response.ok) {
                // æ›´æ–°æœ¬åœ°çŠ¶æ€
                shape.name = newName;
                shape.is_named = true;

                // å‘å¯¼æ¨¡å¼ä¸‹ä¿å­˜é¢å¤–å±æ€§åˆ°æœ¬åœ°çŠ¶æ€
                if (isWizardMode) {
                    shape.hint = hint;
                    shape.max_chars = maxChars;
                    shape.required = required;
                }

                renderElementList();
                renderPageList();
                updateProgress();
                renderPropertyPanel(shape);

                // æ›´æ–°ç¼–è¾‘ä¼šè¯è¿›åº¦
                saveEditSession();

                showSuccess('âœ… ä¿å­˜æˆåŠŸ');
            } else {
                showError('ä¿å­˜å¤±è´¥: ' + data.error);
            }
        } catch (error) {
            showError('ä¿å­˜å¤±è´¥: ' + error.message);
        }
    }

    // å…¼å®¹æ—§è°ƒç”¨
    function saveShapeName(shapeId) {
        saveShapeProperties(shapeId);
    }

    // æ›´æ–°é¡µé¢åç§°
    function updatePageName(pageNum, newName) {
        const page = templateEditorState.pages.find(p => p.page_num === pageNum);
        if (!page) return;

        const trimmedName = newName.trim();
        if (!trimmedName) {
            // å¦‚æœä¸ºç©ºï¼Œæ¢å¤é»˜è®¤åç§°
            page.page_type = `ç¬¬${pageNum}é¡µ`;
        } else {
            page.page_type = trimmedName;
        }

        // æ›´æ–°é¡µé¢åˆ—è¡¨æ˜¾ç¤º
        renderPageList();

        // ä¿å­˜ä¼šè¯
        saveEditSession();
    }

    // æ›´æ–°é¡µé¢å¤‡æ³¨ï¼ˆå‘å¯¼æ¨¡å¼ä¸‹ä½¿ç”¨ï¼‰
    function updatePageNote(pageNum, newNote) {
        const page = templateEditorState.pages.find(p => p.page_num === pageNum);
        if (!page) return;

        page.note = newNote.trim();

        // ä¿å­˜ä¼šè¯
        saveEditSession();
    }

    // é¡µé¢å¤‡æ³¨æ¨¡æ€æ¡†ç›¸å…³
    let currentNotePageNum = null;

    function openPageNoteModal(pageNum) {
        currentNotePageNum = pageNum;
        const page = templateEditorState.pages.find(p => p.page_num === pageNum);
        if (!page) return;

        document.getElementById('pageNoteTextarea').value = page.note || '';
        const modal = document.getElementById('pageNoteModal');
        modal.style.display = 'flex';

        // èšç„¦åˆ°æ–‡æœ¬æ¡†
        setTimeout(() => {
            document.getElementById('pageNoteTextarea').focus();
        }, 100);
    }

    function closePageNoteModal() {
        document.getElementById('pageNoteModal').style.display = 'none';
        currentNotePageNum = null;
    }

    function savePageNote() {
        if (currentNotePageNum === null) return;

        const newNote = document.getElementById('pageNoteTextarea').value.trim();
        updatePageNote(currentNotePageNum, newNote);

        // åˆ·æ–°å½“å‰é¡µé¢æ ‡é¢˜åŒºåŸŸçš„æŒ‰é’®çŠ¶æ€
        loadPage(currentNotePageNum);

        closePageNoteModal();
        showSuccess('é¡µé¢å¤‡æ³¨å·²ä¿å­˜');
    }

    // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
    document.getElementById('pageNoteModal')?.addEventListener('click', function (e) {
        if (e.target === this) {
            closePageNoteModal();
        }
    });

    // Toggle shape visibility
    async function toggleShapeVisibility(shapeId) {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const shape = page.shapes.find(s => s.shape_id === shapeId);

        if (!shape) return;

        const newHiddenState = !shape.is_hidden;

        try {
            // 1. æ›´æ–°å‰ç«¯çŠ¶æ€
            shape.is_hidden = newHiddenState;

            // 2. é€šçŸ¥åç«¯ï¼ˆå¯é€‰ï¼Œç”¨äºæŒä¹…åŒ–ï¼‰
            await fetch('/developer-tools/toggle-shape-visibility/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shape_id: shape.shape_id,
                    is_hidden: newHiddenState
                })
            });

            // 3. åˆ·æ–°é¢„è§ˆå›¾ï¼ˆæ›´æ–°æ ‡æ³¨ï¼‰
            console.log('[toggleShapeVisibility] åˆ·æ–°é¢„è§ˆå›¾, shapes:', page.shapes.map(s => ({
                name: s.name,
                shape_id: s.shape_id,
                is_hidden: s.is_hidden
            })));

            const previewResponse = await fetch('/developer-tools/refresh-preview/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shapes: page.shapes  // ä¼ å…¥å®Œæ•´çš„ shapes åˆ—è¡¨ï¼ˆåŒ…å« is_hidden çŠ¶æ€ï¼‰
                })
            });

            const previewData = await previewResponse.json();
            console.log('[toggleShapeVisibility] é¢„è§ˆå›¾å“åº”:', previewData);

            if (previewResponse.ok && previewData.image_url) {
                // æ›´æ–°é¢„è§ˆå›¾
                const newImageUrl = previewData.image_url + '?t=' + Date.now();  // åŠ æ—¶é—´æˆ³é˜²æ­¢ç¼“å­˜
                console.log('[toggleShapeVisibility] æ›´æ–°é¢„è§ˆå›¾:', newImageUrl);
                page.image_url = newImageUrl;
                document.getElementById('previewImage').src = newImageUrl;
            } else {
                console.error('[toggleShapeVisibility] åˆ·æ–°é¢„è§ˆå›¾å¤±è´¥:', previewData);
            }

            // 4. æ›´æ–° UI
            renderElementList();
            renderPageList();
            renderPropertyPanel(shape);
            updateProgress();

            // 5. ä¿å­˜ç¼–è¾‘ä¼šè¯ï¼ˆæŒä¹…åŒ–éšè—çŠ¶æ€ï¼‰
            saveEditSession();

            showSuccess(newHiddenState ? 'å…ƒç´ å·²éšè—' : 'å…ƒç´ å·²æ˜¾ç¤º');
        } catch (error) {
            // å›æ»šçŠ¶æ€
            shape.is_hidden = !newHiddenState;
            showError('æ“ä½œå¤±è´¥: ' + error.message);
        }
    }

    // Update progress
    function updateProgress() {
        let totalShapes = 0;
        let namedShapes = 0;

        templateEditorState.pages.forEach(page => {
            page.shapes.forEach(shape => {
                if (!shape.is_hidden) {
                    totalShapes++;
                    if (shape.is_named) {
                        namedShapes++;
                    }
                }
            });
        });

        const percent = totalShapes > 0 ? Math.round(namedShapes / totalShapes * 100) : 0;
        document.getElementById('namedCount').textContent = `${namedShapes} / ${totalShapes}`;
        document.getElementById('progressBar').style.width = percent + '%';
        document.getElementById('progressPercent').textContent = percent + '%';

        // æ›´æ–°å½“å‰é¡µçš„å…ƒç´ ç»Ÿè®¡
        updateElementStats();
    }

    // æ›´æ–°å…ƒç´ ç»Ÿè®¡ä¿¡æ¯
    function updateElementStats() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        const statsEl = document.getElementById('elementStats');
        if (!page || !statsEl) return;

        const total = page.shapes.length;
        const visible = page.shapes.filter(s => !s.is_hidden).length;
        const named = page.shapes.filter(s => !s.is_hidden && s.is_named).length;
        const selectedCount = templateEditorState.selectedShapeIds?.length || 0;

        if (templateEditorState.multiSelectMode && selectedCount > 0) {
            statsEl.textContent = `å·²é€‰ ${selectedCount} | æ˜¾ç¤º ${visible}/${total}`;
            statsEl.style.background = 'rgba(52, 152, 219, 0.2)';
            statsEl.style.color = 'var(--primary-color)';
        } else {
            statsEl.textContent = `æ˜¾ç¤º ${visible}/${total} | å·²å‘½å ${named}`;
            statsEl.style.background = 'white';
            statsEl.style.color = 'var(--text-secondary)';
        }
    }

    // ========================================
    // æ‰¹é‡æ“ä½œåŠŸèƒ½
    // ========================================

    // æ‰¹é‡æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
    async function batchShowAll() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const hiddenShapes = page.shapes.filter(s => s.is_hidden);
        if (hiddenShapes.length === 0) {
            showInfo('æ²¡æœ‰éšè—çš„å…ƒç´ ');
            return;
        }

        await batchUpdateVisibility(page, page.shapes, false);
        showSuccess(`å·²æ˜¾ç¤º ${hiddenShapes.length} ä¸ªå…ƒç´ `);
    }

    // æ‰¹é‡éšè—æ‰€æœ‰å…ƒç´ 
    async function batchHideAll() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) {
            showInfo('æ²¡æœ‰å¯éšè—çš„å…ƒç´ ');
            return;
        }

        await batchUpdateVisibility(page, page.shapes, true);
        showSuccess(`å·²éšè— ${visibleShapes.length} ä¸ªå…ƒç´ `);
    }

    // æ‰¹é‡éšè—æœªå‘½åå…ƒç´ 
    async function batchHideUnnamed() {
        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) return;

        const unnamedShapes = page.shapes.filter(s => !s.is_named && !s.is_hidden);
        if (unnamedShapes.length === 0) {
            showInfo('æ²¡æœ‰æœªå‘½åçš„å¯è§å…ƒç´ ');
            return;
        }

        // åªéšè—æœªå‘½åçš„å…ƒç´ 
        unnamedShapes.forEach(s => s.is_hidden = true);
        await refreshPreviewAfterBatch(page);
        showSuccess(`å·²éšè— ${unnamedShapes.length} ä¸ªæœªå‘½åå…ƒç´ `);
    }

    // æ‰¹é‡æ›´æ–°å¯è§æ€§
    async function batchUpdateVisibility(page, shapes, isHidden) {
        shapes.forEach(s => s.is_hidden = isHidden);
        await refreshPreviewAfterBatch(page);
    }

    // æ‰¹é‡æ“ä½œååˆ·æ–°é¢„è§ˆ
    async function refreshPreviewAfterBatch(page) {
        try {
            const previewResponse = await fetch('/developer-tools/refresh-preview/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: templateEditorState.currentPageNum,
                    shapes: page.shapes
                })
            });

            const previewData = await previewResponse.json();

            if (previewResponse.ok && previewData.image_url) {
                const newImageUrl = previewData.image_url + '?t=' + Date.now();
                page.image_url = newImageUrl;
                document.getElementById('previewImage').src = newImageUrl;
            }

            // æ›´æ–° UI
            renderElementList();
            renderPageList();
            updateProgress();

            // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            templateEditorState.selectedShapeId = null;
            switchPropertyTab('list');

            // ä¿å­˜ç¼–è¾‘ä¼šè¯ï¼ˆæŒä¹…åŒ–éšè—çŠ¶æ€ï¼‰
            saveEditSession();

        } catch (error) {
            showError('åˆ·æ–°é¢„è§ˆå¤±è´¥: ' + error.message);
        }
    }

    // ========================================
    // Toolbar Actions
    // ========================================

    // å›¾ç‰‡ç¼©æ”¾çŠ¶æ€
    let imageZoom = 100;

    // Zoom controls
    document.getElementById('zoomInBtn')?.addEventListener('click', () => {
        imageZoom = Math.min(200, imageZoom + 25);
        updateImageZoom();
    });

    document.getElementById('zoomOutBtn')?.addEventListener('click', () => {
        imageZoom = Math.max(25, imageZoom - 25);
        updateImageZoom();
    });

    document.getElementById('fitToWindowBtn')?.addEventListener('click', () => {
        imageZoom = 100;
        updateImageZoom();
    });

    function updateImageZoom() {
        const img = document.getElementById('previewImage');
        if (img) {
            img.style.transform = `scale(${imageZoom / 100})`;
            img.style.transformOrigin = 'center center';
        }
        document.getElementById('zoomLevel').textContent = imageZoom + '%';
    }

    // Upload new template
    document.getElementById('uploadNewBtn')?.addEventListener('click', () => {
        document.getElementById('uploadSection').style.display = 'block';
        document.getElementById('editorSection').style.display = 'none';
        document.getElementById('uploadTemplateForm').reset();
    });

    // AI å‘½åçŠ¶æ€æ ‡å¿—ï¼ˆé˜²æ­¢é‡å¤ç‚¹å‡»ï¼‰
    let isAINaming = false;

    // AI å‘½åå•ä¸ªé¡µé¢çš„æ ¸å¿ƒå‡½æ•°
    // forceOverride: true=å¼ºåˆ¶è¦†ç›–æ‰€æœ‰é…ç½®, false=åªè¡¥å…¨ç¼ºå¤±çš„é…ç½®
    async function aiNamePage(page, showProgress = true, forceOverride = false) {
        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) {
            return { success: true, count: 0, skipped: true };
        }

        // æ„å»ºç°æœ‰é…ç½®ä¿¡æ¯ï¼ˆå¼ºåˆ¶è¦†ç›–æ¨¡å¼ä¸‹ä¼ ç©ºé…ç½®ï¼‰
        const existingConfig = forceOverride ? {} : {
            page_type: page.page_type || '',
            page_note: page.note || '',
            elements: visibleShapes.map((s, idx) => ({
                index: idx + 1,
                name: s.name || '',
                hint: s.hint || '',
                max_chars: s.max_chars || null,
                required: s.required || false
            }))
        };

        try {
            const response = await fetch('/developer-tools/ai-auto-name/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId,
                    page_num: page.page_num,
                    image_url: page.image_url,
                    shapes: page.shapes,
                    existing_config: existingConfig,  // ä¼ å…¥ç°æœ‰é…ç½®ï¼ˆè¦†ç›–æ¨¡å¼ä¸ºç©ºï¼‰
                    wizard_mode: templateEditorState.wizardMode,  // å‘ŠçŸ¥åç«¯æ˜¯å¦å‘å¯¼æ¨¡å¼
                    force_override: forceOverride  // æ˜¯å¦å¼ºåˆ¶è¦†ç›–
                })
            });

            const data = await response.json();

            if (!response.ok) {
                return { success: false, error: data.error || 'æœªçŸ¥é”™è¯¯' };
            }

            // åº”ç”¨é¡µé¢åç§°
            if (data.page_type) {
                if (forceOverride || !page.page_type || page.page_type === `ç¬¬${page.page_num}é¡µ`) {
                    page.page_type = data.page_type;
                }
            }

            // å‘å¯¼æ¨¡å¼ä¸‹ï¼šåº”ç”¨é¡µé¢å¤‡æ³¨
            if (templateEditorState.wizardMode && data.page_note) {
                if (forceOverride || !page.note) {
                    page.note = data.page_note;
                }
            }

            // åº”ç”¨ AI å»ºè®®çš„å…ƒç´ é…ç½®
            const namedShapes = data.named_shapes || [];
            let successCount = 0;
            let updatedCount = 0;

            for (let i = 0; i < namedShapes.length; i++) {
                const suggestion = namedShapes[i];
                const shape = page.shapes.find(s => s.shape_index === suggestion.shape_index);
                if (shape) {
                    let needsSave = false;

                    // æ›´æ–°åç§°ï¼ˆå¼ºåˆ¶è¦†ç›– æˆ– ç¼ºå¤±æ—¶ï¼‰
                    if (suggestion.suggested_name) {
                        if (forceOverride || !shape.name || shape.name === 'æœªå‘½å') {
                            shape.name = suggestion.suggested_name;
                            shape.is_named = true;
                            needsSave = true;
                        }
                    }

                    // å‘å¯¼æ¨¡å¼ä¸‹ï¼šåº”ç”¨é…ç½®ä¿¡æ¯
                    if (templateEditorState.wizardMode) {
                        // hintï¼ˆå¼ºåˆ¶è¦†ç›– æˆ– ç¼ºå¤±æ—¶ï¼‰
                        if (suggestion.hint && (forceOverride || !shape.hint)) {
                            shape.hint = suggestion.hint;
                            updatedCount++;
                        }
                        // max_charsï¼ˆå¼ºåˆ¶è¦†ç›– æˆ– ç¼ºå¤±æ—¶ï¼‰
                        if (suggestion.max_chars !== null && suggestion.max_chars !== undefined) {
                            if (forceOverride || !shape.max_chars) {
                                shape.max_chars = suggestion.max_chars;
                                updatedCount++;
                            }
                        }
                        // requiredï¼ˆå¼ºåˆ¶è¦†ç›– æˆ– æœªè®¾ç½®æ—¶ï¼‰
                        if (suggestion.required !== undefined) {
                            if (forceOverride || shape.required === undefined) {
                                shape.required = suggestion.required;
                                updatedCount++;
                            }
                        }
                    }

                    // ä¿å­˜åç§°å˜æ›´
                    if (needsSave) {
                        try {
                            await fetch('/developer-tools/update-shape-name/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': getCookie('csrftoken')
                                },
                                body: JSON.stringify({
                                    template_id: templateEditorState.templateId,
                                    page_num: page.page_num,
                                    shape_id: shape.shape_id,  // ä½¿ç”¨ shape_id è€Œä¸æ˜¯ shape_index
                                    new_name: suggestion.suggested_name
                                })
                            });
                            successCount++;

                            // çŸ­å»¶è¿Ÿé¿å…è§¦å‘åç«¯é™æµï¼ˆæ¯ä¿å­˜ä¸€ä¸ªç­‰50msï¼‰
                            if (i < namedShapes.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 50));
                            }
                        } catch (e) {
                            console.error('ä¿å­˜å¤±è´¥:', suggestion, e);
                        }
                    }
                }
            }

            // å‘å¯¼æ¨¡å¼ä¸‹ä¿å­˜ä¼šè¯
            if (templateEditorState.wizardMode) {
                saveEditSession();
            }

            return { success: true, count: successCount, pageType: data.page_type || null, pageNote: data.page_note || null };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    // AI å‘½åæœ¬é¡µ
    document.getElementById('aiAutoNameBtn')?.addEventListener('click', async () => {
        if (isAINaming) {
            showWarning('AI æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...');
            return;
        }

        const page = templateEditorState.pages.find(p => p.page_num === templateEditorState.currentPageNum);
        if (!page) {
            showWarning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¡µé¢');
            return;
        }

        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) {
            showWarning('å½“å‰é¡µé¢æ²¡æœ‰å¯å‘½åçš„å…ƒç´ ');
            return;
        }

        isAINaming = true;
        const loadingMsg = templateEditorState.wizardMode
            ? 'ğŸ¤– AI æ­£åœ¨åˆ†æé¡µé¢å¹¶ç”Ÿæˆé…ç½®...'
            : 'ğŸ¤– AI æ­£åœ¨åˆ†æå½“å‰é¡µé¢å…ƒç´ ...';
        showLoading(loadingMsg);

        try {
            const result = await aiNamePage(page);
            hideLoading();

            if (result.success) {
                renderElementList();
                renderPageList();
                updateProgress();
                // åˆ·æ–°é¡µé¢ä»¥æ˜¾ç¤ºæ–°çš„é¡µé¢åç§°å’Œå¤‡æ³¨æŒ‰é’®çŠ¶æ€
                loadPage(page.page_num);

                // æ„å»ºæˆåŠŸæ¶ˆæ¯
                let successMsg = `âœ… AI æˆåŠŸå‘½å ${result.count} ä¸ªå…ƒç´ `;
                if (result.pageType) successMsg += `ï¼Œé¡µé¢å‘½åä¸º"${result.pageType}"`;
                if (templateEditorState.wizardMode && result.pageNote) {
                    successMsg += `ï¼Œå·²æ·»åŠ é¡µé¢å¤‡æ³¨`;
                }
                showSuccess(successMsg);
            } else {
                showError('AI å‘½åå¤±è´¥: ' + result.error);
            }
        } finally {
            isAINaming = false;
        }
    });

    // æ£€æŸ¥é¡µé¢é…ç½®æ˜¯å¦å®Œæ•´ï¼ˆå‘å¯¼æ¨¡å¼ä¸‹éœ€è¦æ£€æŸ¥æ›´å¤šå­—æ®µï¼‰
    function isPageConfigComplete(page) {
        const visibleShapes = page.shapes.filter(s => !s.is_hidden);
        if (visibleShapes.length === 0) return true;

        // æ£€æŸ¥é¡µé¢åç§°
        if (!page.page_type || page.page_type === `ç¬¬${page.page_num}é¡µ`) return false;

        // å‘å¯¼æ¨¡å¼ä¸‹è¿˜è¦æ£€æŸ¥å…ƒç´ é…ç½®
        if (templateEditorState.wizardMode) {
            for (const shape of visibleShapes) {
                // æ£€æŸ¥åç§°
                if (!shape.name || shape.name === 'æœªå‘½å') return false;
                // æ£€æŸ¥ hint
                if (!shape.hint) return false;
            }
        } else {
            // éå‘å¯¼æ¨¡å¼åªæ£€æŸ¥åç§°
            for (const shape of visibleShapes) {
                if (!shape.name || shape.name === 'æœªå‘½å') return false;
            }
        }

        return true;
    }

    // AI å‘½åå…¨éƒ¨é¡µé¢æ ¸å¿ƒé€»è¾‘
    // forceOverride: true=å¼ºåˆ¶é‡å‘½åæ‰€æœ‰é¡µé¢, false=åªè¡¥å…¨ç¼ºå¤±çš„é…ç½®
    async function aiAutoNameAllPages(skipConfirm = false, forceOverride = false) {
        if (isAINaming) {
            showWarning('AI æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...');
            return;
        }

        let pagesToName;
        let confirmMsg;

        if (forceOverride) {
            // å¼ºåˆ¶è¦†ç›–æ¨¡å¼ï¼šå¤„ç†æ‰€æœ‰æœ‰å…ƒç´ çš„é¡µé¢
            pagesToName = templateEditorState.pages.filter(p => {
                const visibleShapes = p.shapes.filter(s => !s.is_hidden);
                return visibleShapes.length > 0;
            });

            if (pagesToName.length === 0) {
                showWarning('æ²¡æœ‰éœ€è¦å‘½åçš„é¡µé¢');
                return;
            }

            confirmMsg = `ç¡®å®šè¦ä½¿ç”¨ AI é‡æ–°å‘½åå…¨éƒ¨ ${pagesToName.length} ä¸ªé¡µé¢å—ï¼Ÿ\n\nâš ï¸ è¿™å°†è¦†ç›–æ‰€æœ‰ç°æœ‰çš„å‘½åå’Œé…ç½®ï¼`;
        } else {
            // æŸ¥æ¼è¡¥ç¼ºæ¨¡å¼ï¼šåªå¤„ç†é…ç½®ä¸å®Œæ•´çš„é¡µé¢
            pagesToName = templateEditorState.pages.filter(p => {
                const visibleShapes = p.shapes.filter(s => !s.is_hidden);
                return visibleShapes.length > 0 && !isPageConfigComplete(p);
            });

            if (pagesToName.length === 0) {
                showWarning('æ‰€æœ‰é¡µé¢é…ç½®å·²å®Œæ•´');
                // é€šçŸ¥çˆ¶çª—å£å®Œæˆ
                if (templateEditorState.embeddedMode && window.parent !== window) {
                    window.parent.postMessage({ type: 'aiNamingComplete' }, '*');
                }
                return;
            }

            confirmMsg = templateEditorState.wizardMode
                ? `å‘ç° ${pagesToName.length} ä¸ªé¡µé¢é…ç½®ä¸å®Œæ•´ï¼ˆç¼ºå°‘é¡µé¢åç§°ã€å…ƒç´ åç§°æˆ–æç¤ºä¿¡æ¯ï¼‰ã€‚\n\nç¡®å®šè®© AI è¡¥å…¨è¿™äº›é…ç½®å—ï¼Ÿ`
                : `ç¡®å®šè¦ä½¿ç”¨ AI å‘½å ${pagesToName.length} ä¸ªæœªå®Œæˆçš„é¡µé¢å—ï¼Ÿ\n\nè¿™å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚`;
        }

        if (!skipConfirm && !confirm(confirmMsg)) {
            // é€šçŸ¥çˆ¶çª—å£å–æ¶ˆ
            if (templateEditorState.embeddedMode && window.parent !== window) {
                window.parent.postMessage({ type: 'aiNamingComplete' }, '*');
            }
            return;
        }

        isAINaming = true;
        let totalSuccess = 0;
        let totalFailed = 0;
        const modeLabel = forceOverride ? 'é‡å‘½å' : 'è¡¥å…¨';

        for (let i = 0; i < pagesToName.length; i++) {
            const page = pagesToName[i];
            const progressMsg = `ğŸ¤– AI æ­£åœ¨${modeLabel}ç¬¬ ${page.page_num} é¡µ (${i + 1}/${pagesToName.length})...`;
            showLoading(progressMsg);

            // é€šçŸ¥çˆ¶çª—å£è¿›åº¦
            if (templateEditorState.embeddedMode && window.parent !== window) {
                window.parent.postMessage({ type: 'aiNamingProgress', message: progressMsg }, '*');
            }

            const result = await aiNamePage(page, false, forceOverride);

            if (result.success) {
                totalSuccess += result.count;
            } else {
                totalFailed++;
                console.error(`ç¬¬ ${page.page_num} é¡µ${modeLabel}å¤±è´¥:`, result.error);
            }

            // æ›´æ–° UI
            renderPageList();
            updateProgress();

            // å»¶è¿Ÿé¿å… API é™æµï¼ˆGLM ç­‰ API å¯¹å¹¶å‘è¦æ±‚ä¸¥æ ¼ï¼‰
            if (i < pagesToName.length - 1) {
                const waitMsg = `â³ ç­‰å¾… 3 ç§’é¿å… API é™æµ...`;
                showLoading(waitMsg);
                if (templateEditorState.embeddedMode && window.parent !== window) {
                    window.parent.postMessage({ type: 'aiNamingProgress', message: waitMsg }, '*');
                }
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
        }

        hideLoading();
        isAINaming = false;

        // åˆ·æ–°å½“å‰é¡µé¢çš„å…ƒç´ åˆ—è¡¨
        renderElementList();

        if (totalFailed === 0) {
            showSuccess(`âœ… AI æ‰¹é‡${modeLabel}å®Œæˆï¼å…±å¤„ç† ${totalSuccess} ä¸ªå…ƒç´ `);
        } else {
            showWarning(`âš ï¸ æ‰¹é‡${modeLabel}å®Œæˆï¼ŒæˆåŠŸ ${totalSuccess} ä¸ªå…ƒç´ ï¼Œ${totalFailed} ä¸ªé¡µé¢å¤±è´¥`);
        }

        // é€šçŸ¥çˆ¶çª—å£å®Œæˆ
        if (templateEditorState.embeddedMode && window.parent !== window) {
            window.parent.postMessage({ type: 'aiNamingComplete' }, '*');
        }
    }

    // AI ä¸€é”®å‘½åï¼ˆå¼ºåˆ¶è¦†ç›–æ¨¡å¼ï¼‰
    document.getElementById('aiAutoNameAllBtn')?.addEventListener('click', () => aiAutoNameAllPages(false, true));

    // AI æŸ¥æ¼è¡¥ç¼ºï¼ˆä¿ç•™ç°æœ‰é…ç½®ï¼‰
    document.getElementById('aiAutoFillBtn')?.addEventListener('click', () => aiAutoNameAllPages(false, false));

    // ç›‘å¬æ¥è‡ªçˆ¶çª—å£çš„æ¶ˆæ¯ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
    window.addEventListener('message', function (event) {
        if (event.data.type === 'triggerAiAutoNameAll') {
            // ä»å‘å¯¼è§¦å‘ï¼Œè·³è¿‡ç¡®è®¤å¼¹çª—
            // forceOverride: true=å¼ºåˆ¶é‡å‘½å, false=æŸ¥æ¼è¡¥ç¼º
            const forceOverride = event.data.forceOverride === true;
            aiAutoNameAllPages(true, forceOverride);
        }

        // å‘å¯¼è¯·æ±‚è·å–å®Œæ•´é…ç½®æ•°æ®ï¼ˆç”¨äºå‘å¸ƒæ¨¡æ¿ï¼‰
        if (event.data.type === 'getFullConfig') {
            const config = generateFullConfig();
            window.parent.postMessage({ type: 'fullConfigData', config: config }, '*');
        }

        // ä»å‘å¯¼æ¥æ”¶åˆå§‹é…ç½®æ•°æ®ï¼ˆç¼–è¾‘å·²å‘å¸ƒæ¨¡æ¿æ—¶ï¼‰
        if (event.data.type === 'applyInitialConfig') {
            console.log('[applyInitialConfig] æ¥æ”¶åˆ°åˆå§‹é…ç½®:', event.data.config);
            applyConfigFromJSON(event.data.config);
        }
    });

    // ä» JSON é…ç½®æ¢å¤ç¼–è¾‘å™¨çŠ¶æ€ï¼ˆç¼–è¾‘å·²å‘å¸ƒæ¨¡æ¿æ—¶ä½¿ç”¨ï¼‰
    function applyConfigFromJSON(configData) {
        if (!configData || !configData.ppt_pages) {
            console.log('[applyConfigFromJSON] é…ç½®æ•°æ®æ— æ•ˆ');
            return;
        }

        // ç­‰å¾…é¡µé¢æ•°æ®åŠ è½½å®Œæˆ
        const checkAndApply = () => {
            if (!templateEditorState.pages || templateEditorState.pages.length === 0) {
                console.log('[applyConfigFromJSON] ç­‰å¾…é¡µé¢æ•°æ®åŠ è½½...');
                setTimeout(checkAndApply, 200);
                return;
            }

            console.log('[applyConfigFromJSON] å¼€å§‹åº”ç”¨é…ç½®');

            // éå†é…ç½®ä¸­çš„æ¯ä¸€é¡µ
            configData.ppt_pages.forEach((pageConfig, index) => {
                const pageNum = index + 1;
                const page = templateEditorState.pages.find(p => p.page_num === pageNum);
                if (!page) return;

                // åº”ç”¨é¡µé¢åç§°
                if (pageConfig.page_type) {
                    page.page_type = pageConfig.page_type;
                }

                // åº”ç”¨é¡µé¢å¤‡æ³¨
                if (pageConfig.page_note) {
                    page.note = pageConfig.page_note;
                }

                // åº”ç”¨å…ƒç´ é…ç½®
                if (pageConfig.content) {
                    Object.entries(pageConfig.content).forEach(([fieldName, fieldConfig]) => {
                        // æŸ¥æ‰¾åŒ¹é…çš„å½¢çŠ¶ï¼ˆé€šè¿‡åç§°åŒ¹é…ï¼‰
                        const shape = page.shapes.find(s => s.name === fieldName);
                        if (shape) {
                            shape.is_named = true;
                            if (fieldConfig.hint) shape.hint = fieldConfig.hint;
                            if (fieldConfig.max_chars) shape.max_chars = fieldConfig.max_chars;
                            if (fieldConfig.required !== undefined) shape.required = fieldConfig.required;
                        }
                    });
                }
            });

            // åˆ·æ–°æ˜¾ç¤º
            if (typeof renderPageList === 'function') renderPageList();
            if (typeof renderShapeList === 'function') renderShapeList();
            console.log('[applyConfigFromJSON] é…ç½®åº”ç”¨å®Œæˆ');
        };

        checkAndApply();
    }

    // ç”Ÿæˆå®Œæ•´çš„ config.json æ ¼å¼æ•°æ®ï¼ˆå‘å¯¼æ¨¡å¼ï¼‰
    function generateFullConfig() {
        if (!templateEditorState.pages || templateEditorState.pages.length === 0) {
            console.log('[generateFullConfig] æ²¡æœ‰é¡µé¢æ•°æ®');
            return null;
        }

        const manifest = [];
        const pptPages = [];

        templateEditorState.pages.forEach(page => {
            const content = {};
            let textSlots = 0;
            let imageSlots = 0;

            // éå†æ‰€æœ‰ééšè—çš„å…ƒç´ 
            page.shapes.forEach(shape => {
                if (shape.is_hidden) return;  // è·³è¿‡éšè—å…ƒç´ 
                if (!shape.name || shape.name === 'æœªå‘½å') return;  // è·³è¿‡æœªå‘½åå…ƒç´ 

                // ç¡®å®šå­—æ®µç±»å‹
                let fieldType = 'text';
                if (shape.shape_type === 'picture' || shape.name.includes('å›¾')) {
                    fieldType = 'image';
                    imageSlots++;
                } else {
                    textSlots++;
                }

                content[shape.name] = {
                    type: fieldType,
                    hint: shape.hint || `å¡«å†™${shape.name}çš„å†…å®¹`,
                    required: shape.required !== false,  // é»˜è®¤å¿…å¡«
                    value: '',
                    max_chars: shape.max_chars || null
                };
            });

            // åªæœ‰æœ‰å†…å®¹çš„é¡µé¢æ‰æ·»åŠ 
            if (Object.keys(content).length > 0) {
                const pageType = page.page_type || `ç¬¬${page.page_num}é¡µ`;

                // æ·»åŠ åˆ° manifest
                manifest.push({
                    template_page_num: page.page_num,
                    page_type: pageType,
                    text_slots: textSlots,
                    image_slots: imageSlots
                });

                // æ·»åŠ åˆ° ppt_pages
                const pageConfig = {
                    page_type: pageType,
                    template_page_num: page.page_num,
                    content: content,
                    meta: {
                        layout: pageType,
                        scene: [],
                        style: '',
                        text_slots: textSlots,
                        image_slots: imageSlots,
                        notes: page.note || 'è¯·æ ¹æ®å®é™…éœ€è¦å¡«å†™å†…å®¹'
                    }
                };

                pptPages.push(pageConfig);
            }
        });

        const config = {
            manifest: manifest,
            ppt_pages: pptPages
        };

        console.log('[generateFullConfig] ç”Ÿæˆé…ç½®:', config);
        return config;
    }

    // Save PPT
    document.getElementById('saveTemplateBtn')?.addEventListener('click', async () => {
        if (!templateEditorState.templateId) {
            showWarning('æ²¡æœ‰å¯ä¿å­˜çš„æ¨¡æ¿');
            return;
        }

        try {
            showLoading('æ­£åœ¨ä¿å­˜ PPT...');

            const url = `/developer-tools/download-ppt/${templateEditorState.templateId}/`;
            const a = document.createElement('a');
            a.href = url;
            a.download = 'template.pptx';
            a.click();

            hideLoading();
            showSuccess('PPT å·²ä¿å­˜ï¼');
        } catch (error) {
            hideLoading();
            showError('ä¿å­˜å¤±è´¥: ' + error.message);
        }
    });

    // Generate config JSON
    document.getElementById('generateConfigBtn')?.addEventListener('click', async () => {
        if (!templateEditorState.templateId) {
            showWarning('æ²¡æœ‰å¯ç”Ÿæˆçš„é…ç½®');
            return;
        }

        try {
            showLoading('æ­£åœ¨ç”Ÿæˆé…ç½® JSON...');

            const response = await fetch('/developer-tools/generate-config/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    template_id: templateEditorState.templateId
                })
            });

            const data = await response.json();

            if (response.ok) {
                downloadJSON(data.config, 'template_config.json');
                hideLoading();
                showSuccess('é…ç½® JSON å·²ç”Ÿæˆï¼');
            } else {
                hideLoading();
                showError('ç”Ÿæˆå¤±è´¥: ' + data.error);
            }
        } catch (error) {
            hideLoading();
            showError('ç”Ÿæˆå¤±è´¥: ' + error.message);
        }
    });

    // ========================================
    // Keyboard Shortcuts
    // ========================================

    document.addEventListener('keydown', function (e) {
        // Ignore if typing in input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        // Ctrl+S: Save PPT
        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            document.getElementById('saveTemplateBtn')?.click();
        }

        // Ctrl+G: Generate config
        if (e.ctrlKey && e.key === 'g') {
            e.preventDefault();
            document.getElementById('generateConfigBtn')?.click();
        }

        // Arrow keys: Switch pages
        if (e.key === 'ArrowLeft') {
            const prevPage = templateEditorState.currentPageNum - 1;
            if (prevPage >= 1) {
                loadPage(prevPage);
            }
        }
        if (e.key === 'ArrowRight') {
            const nextPage = templateEditorState.currentPageNum + 1;
            if (nextPage <= templateEditorState.pages.length) {
                loadPage(nextPage);
            }
        }

        // +/-: Zoom
        if (e.key === '+' || e.key === '=') {
            e.preventDefault();
            imageZoom = Math.min(200, imageZoom + 25);
            updateImageZoom();
        }
        if (e.key === '-') {
            e.preventDefault();
            imageZoom = Math.max(25, imageZoom - 25);
            updateImageZoom();
        }

        // 0: Fit to window
        if (e.key === '0') {
            e.preventDefault();
            imageZoom = 100;
            updateImageZoom();
        }
    });

    // ========================================
    // File Upload UI Enhancement
    // ========================================

    document.getElementById('ppt_file')?.addEventListener('change', function () {
        const label = this.nextElementSibling;
        if (this.files.length > 0) {
            label.textContent = this.files[0].name;
        }
    });

    // ========================================
    // Property Tab Switching
    // ========================================

    document.querySelectorAll('.property-tab').forEach((tab, index) => {
        tab.addEventListener('click', () => {
            switchPropertyTab(index === 0 ? 'list' : 'edit');
        });
    });
</script>
{% endblock %}